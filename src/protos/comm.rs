// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `matrix_io/malos/v1/comm.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg {
    // message fields
    pub field_type: ZigBeeMsg_ZigBeeCmdType,
    pub zcl_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd>,
    pub network_mgmt_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_NetworkMgmtCmd>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg {
    fn default() -> &'a ZigBeeMsg {
        <ZigBeeMsg as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg {
    pub fn new() -> ZigBeeMsg {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZigBeeCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZigBeeCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZigBeeCmdType::ZCL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZigBeeCmdType) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd zcl_cmd = 2;


    pub fn get_zcl_cmd(&self) -> &ZigBeeMsg_ZCLCmd {
        self.zcl_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zcl_cmd(&mut self) {
        self.zcl_cmd.clear();
    }

    pub fn has_zcl_cmd(&self) -> bool {
        self.zcl_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zcl_cmd(&mut self, v: ZigBeeMsg_ZCLCmd) {
        self.zcl_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zcl_cmd(&mut self) -> &mut ZigBeeMsg_ZCLCmd {
        if self.zcl_cmd.is_none() {
            self.zcl_cmd.set_default();
        }
        self.zcl_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_zcl_cmd(&mut self) -> ZigBeeMsg_ZCLCmd {
        self.zcl_cmd.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd network_mgmt_cmd = 3;


    pub fn get_network_mgmt_cmd(&self) -> &ZigBeeMsg_NetworkMgmtCmd {
        self.network_mgmt_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_NetworkMgmtCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_mgmt_cmd(&mut self) {
        self.network_mgmt_cmd.clear();
    }

    pub fn has_network_mgmt_cmd(&self) -> bool {
        self.network_mgmt_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_mgmt_cmd(&mut self, v: ZigBeeMsg_NetworkMgmtCmd) {
        self.network_mgmt_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_mgmt_cmd(&mut self) -> &mut ZigBeeMsg_NetworkMgmtCmd {
        if self.network_mgmt_cmd.is_none() {
            self.network_mgmt_cmd.set_default();
        }
        self.network_mgmt_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_mgmt_cmd(&mut self) -> ZigBeeMsg_NetworkMgmtCmd {
        self.network_mgmt_cmd.take().unwrap_or_else(|| ZigBeeMsg_NetworkMgmtCmd::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.zcl_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_mgmt_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zcl_cmd)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_mgmt_cmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZigBeeCmdType::ZCL {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.zcl_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.network_mgmt_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZigBeeCmdType::ZCL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.zcl_cmd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.network_mgmt_cmd.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg {
        ZigBeeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZigBeeCmdType>>(
                "type",
                |m: &ZigBeeMsg| { &m.field_type },
                |m: &mut ZigBeeMsg| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd>>(
                "zcl_cmd",
                |m: &ZigBeeMsg| { &m.zcl_cmd },
                |m: &mut ZigBeeMsg| { &mut m.zcl_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd>>(
                "network_mgmt_cmd",
                |m: &ZigBeeMsg| { &m.network_mgmt_cmd },
                |m: &mut ZigBeeMsg| { &mut m.network_mgmt_cmd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg>(
                "ZigBeeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZigBeeCmdType::ZCL;
        self.zcl_cmd.clear();
        self.network_mgmt_cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd {
    // message fields
    pub field_type: ZigBeeMsg_ZCLCmd_ZCLCmdType,
    pub onoff_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_OnOffCmd>,
    pub level_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_LevelCmd>,
    pub colorcontrol_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_ColorControlCmd>,
    pub identify_cmd: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_IdentifyCmd>,
    pub node_id: u32,
    pub endpoint_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd {
    fn default() -> &'a ZigBeeMsg_ZCLCmd {
        <ZigBeeMsg_ZCLCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd {
    pub fn new() -> ZigBeeMsg_ZCLCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ZCLCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZCLCmd_ZCLCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZCLCmd_ZCLCmdType) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.OnOffCmd onoff_cmd = 2;


    pub fn get_onoff_cmd(&self) -> &ZigBeeMsg_ZCLCmd_OnOffCmd {
        self.onoff_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_OnOffCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_onoff_cmd(&mut self) {
        self.onoff_cmd.clear();
    }

    pub fn has_onoff_cmd(&self) -> bool {
        self.onoff_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onoff_cmd(&mut self, v: ZigBeeMsg_ZCLCmd_OnOffCmd) {
        self.onoff_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onoff_cmd(&mut self) -> &mut ZigBeeMsg_ZCLCmd_OnOffCmd {
        if self.onoff_cmd.is_none() {
            self.onoff_cmd.set_default();
        }
        self.onoff_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_onoff_cmd(&mut self) -> ZigBeeMsg_ZCLCmd_OnOffCmd {
        self.onoff_cmd.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_OnOffCmd::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd level_cmd = 3;


    pub fn get_level_cmd(&self) -> &ZigBeeMsg_ZCLCmd_LevelCmd {
        self.level_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_LevelCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_level_cmd(&mut self) {
        self.level_cmd.clear();
    }

    pub fn has_level_cmd(&self) -> bool {
        self.level_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_cmd(&mut self, v: ZigBeeMsg_ZCLCmd_LevelCmd) {
        self.level_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_cmd(&mut self) -> &mut ZigBeeMsg_ZCLCmd_LevelCmd {
        if self.level_cmd.is_none() {
            self.level_cmd.set_default();
        }
        self.level_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_level_cmd(&mut self) -> ZigBeeMsg_ZCLCmd_LevelCmd {
        self.level_cmd.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_LevelCmd::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd colorcontrol_cmd = 4;


    pub fn get_colorcontrol_cmd(&self) -> &ZigBeeMsg_ZCLCmd_ColorControlCmd {
        self.colorcontrol_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_ColorControlCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_colorcontrol_cmd(&mut self) {
        self.colorcontrol_cmd.clear();
    }

    pub fn has_colorcontrol_cmd(&self) -> bool {
        self.colorcontrol_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorcontrol_cmd(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd) {
        self.colorcontrol_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_colorcontrol_cmd(&mut self) -> &mut ZigBeeMsg_ZCLCmd_ColorControlCmd {
        if self.colorcontrol_cmd.is_none() {
            self.colorcontrol_cmd.set_default();
        }
        self.colorcontrol_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_colorcontrol_cmd(&mut self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd {
        self.colorcontrol_cmd.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_ColorControlCmd::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd identify_cmd = 5;


    pub fn get_identify_cmd(&self) -> &ZigBeeMsg_ZCLCmd_IdentifyCmd {
        self.identify_cmd.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_IdentifyCmd as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identify_cmd(&mut self) {
        self.identify_cmd.clear();
    }

    pub fn has_identify_cmd(&self) -> bool {
        self.identify_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identify_cmd(&mut self, v: ZigBeeMsg_ZCLCmd_IdentifyCmd) {
        self.identify_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identify_cmd(&mut self) -> &mut ZigBeeMsg_ZCLCmd_IdentifyCmd {
        if self.identify_cmd.is_none() {
            self.identify_cmd.set_default();
        }
        self.identify_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_identify_cmd(&mut self) -> ZigBeeMsg_ZCLCmd_IdentifyCmd {
        self.identify_cmd.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_IdentifyCmd::new())
    }

    // uint32 node_id = 6;


    pub fn get_node_id(&self) -> u32 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = v;
    }

    // uint32 endpoint_index = 7;


    pub fn get_endpoint_index(&self) -> u32 {
        self.endpoint_index
    }
    pub fn clear_endpoint_index(&mut self) {
        self.endpoint_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_endpoint_index(&mut self, v: u32) {
        self.endpoint_index = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd {
    fn is_initialized(&self) -> bool {
        for v in &self.onoff_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.level_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.colorcontrol_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identify_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onoff_cmd)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.level_cmd)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.colorcontrol_cmd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identify_cmd)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_id = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.endpoint_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.onoff_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.level_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.colorcontrol_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.identify_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endpoint_index != 0 {
            my_size += ::protobuf::rt::value_size(7, self.endpoint_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.onoff_cmd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.level_cmd.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.colorcontrol_cmd.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.identify_cmd.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.node_id != 0 {
            os.write_uint32(6, self.node_id)?;
        }
        if self.endpoint_index != 0 {
            os.write_uint32(7, self.endpoint_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd {
        ZigBeeMsg_ZCLCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_ZCLCmdType>>(
                "type",
                |m: &ZigBeeMsg_ZCLCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_OnOffCmd>>(
                "onoff_cmd",
                |m: &ZigBeeMsg_ZCLCmd| { &m.onoff_cmd },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.onoff_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_LevelCmd>>(
                "level_cmd",
                |m: &ZigBeeMsg_ZCLCmd| { &m.level_cmd },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.level_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_ColorControlCmd>>(
                "colorcontrol_cmd",
                |m: &ZigBeeMsg_ZCLCmd| { &m.colorcontrol_cmd },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.colorcontrol_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_IdentifyCmd>>(
                "identify_cmd",
                |m: &ZigBeeMsg_ZCLCmd| { &m.identify_cmd },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.identify_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_id",
                |m: &ZigBeeMsg_ZCLCmd| { &m.node_id },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "endpoint_index",
                |m: &ZigBeeMsg_ZCLCmd| { &m.endpoint_index },
                |m: &mut ZigBeeMsg_ZCLCmd| { &mut m.endpoint_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd>(
                "ZigBeeMsg.ZCLCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF;
        self.onoff_cmd.clear();
        self.level_cmd.clear();
        self.colorcontrol_cmd.clear();
        self.identify_cmd.clear();
        self.node_id = 0;
        self.endpoint_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_OnOffCmd {
    // message fields
    pub field_type: ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_OnOffCmd {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_OnOffCmd {
        <ZigBeeMsg_ZCLCmd_OnOffCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_OnOffCmd {
    pub fn new() -> ZigBeeMsg_ZCLCmd_OnOffCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.OnOffCmd.ZCLOnOffCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_OnOffCmd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_OnOffCmd {
        ZigBeeMsg_ZCLCmd_OnOffCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType>>(
                "type",
                |m: &ZigBeeMsg_ZCLCmd_OnOffCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_ZCLCmd_OnOffCmd| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_OnOffCmd>(
                "ZigBeeMsg.ZCLCmd.OnOffCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_OnOffCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_OnOffCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_OnOffCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_OnOffCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_OnOffCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_OnOffCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
    ON = 0,
    OFF = 1,
    TOGGLE = 2,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::OFF),
            2 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::TOGGLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType] = &[
            ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON,
            ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::OFF,
            ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::TOGGLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType>("ZigBeeMsg.ZCLCmd.OnOffCmd.ZCLOnOffCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType::ON
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_OnOffCmd_ZCLOnOffCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_LevelCmd {
    // message fields
    pub field_type: ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType,
    pub move_to_level_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams>,
    pub move_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_LevelCmd {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_LevelCmd {
        <ZigBeeMsg_ZCLCmd_LevelCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_LevelCmd {
    pub fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd.ZCLLevelCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd.MoveToLevelCmdParams move_to_level_params = 2;


    pub fn get_move_to_level_params(&self) -> &ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        self.move_to_level_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_move_to_level_params(&mut self) {
        self.move_to_level_params.clear();
    }

    pub fn has_move_to_level_params(&self) -> bool {
        self.move_to_level_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_to_level_params(&mut self, v: ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams) {
        self.move_to_level_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_move_to_level_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        if self.move_to_level_params.is_none() {
            self.move_to_level_params.set_default();
        }
        self.move_to_level_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_move_to_level_params(&mut self) -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        self.move_to_level_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd.MoveCmdParams move_params = 3;


    pub fn get_move_params(&self) -> &ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        self.move_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_move_params(&mut self) {
        self.move_params.clear();
    }

    pub fn has_move_params(&self) -> bool {
        self.move_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_params(&mut self, v: ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams) {
        self.move_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_move_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        if self.move_params.is_none() {
            self.move_params.set_default();
        }
        self.move_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_move_params(&mut self) -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        self.move_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_LevelCmd {
    fn is_initialized(&self) -> bool {
        for v in &self.move_to_level_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.move_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.move_to_level_params)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.move_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.move_to_level_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.move_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.move_to_level_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.move_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd {
        ZigBeeMsg_ZCLCmd_LevelCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType>>(
                "type",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams>>(
                "move_to_level_params",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd| { &m.move_to_level_params },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd| { &mut m.move_to_level_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams>>(
                "move_params",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd| { &m.move_params },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd| { &mut m.move_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_LevelCmd>(
                "ZigBeeMsg.ZCLCmd.LevelCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_LevelCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_LevelCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_LevelCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_LevelCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL;
        self.move_to_level_params.clear();
        self.move_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_LevelCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_LevelCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    // message fields
    pub level: u32,
    pub transition_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        <ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        ::std::default::Default::default()
    }

    // uint32 level = 1;


    pub fn get_level(&self) -> u32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = v;
    }

    // uint32 transition_time = 2;


    pub fn get_transition_time(&self) -> u32 {
        self.transition_time
    }
    pub fn clear_transition_time(&mut self) {
        self.transition_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_time(&mut self, v: u32) {
        self.transition_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(1, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.transition_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.transition_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != 0 {
            os.write_uint32(1, self.level)?;
        }
        if self.transition_time != 0 {
            os.write_uint32(2, self.transition_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams| { &m.level },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_time",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams| { &m.transition_time },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams| { &mut m.transition_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams>(
                "ZigBeeMsg.ZCLCmd.LevelCmd.MoveToLevelCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    fn clear(&mut self) {
        self.level = 0;
        self.transition_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_LevelCmd_MoveToLevelCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    // message fields
    pub mode: u32,
    pub rate: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        <ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        ::std::default::Default::default()
    }

    // uint32 mode = 1;


    pub fn get_mode(&self) -> u32 {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = v;
    }

    // uint32 rate = 2;


    pub fn get_rate(&self) -> u32 {
        self.rate
    }
    pub fn clear_rate(&mut self) {
        self.rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_rate(&mut self, v: u32) {
        self.rate = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mode != 0 {
            os.write_uint32(1, self.mode)?;
        }
        if self.rate != 0 {
            os.write_uint32(2, self.rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mode",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams| { &m.mode },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rate",
                |m: &ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams| { &m.rate },
                |m: &mut ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams| { &mut m.rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams>(
                "ZigBeeMsg.ZCLCmd.LevelCmd.MoveCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    fn clear(&mut self) {
        self.mode = 0;
        self.rate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_LevelCmd_MoveCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
    MOVE_TO_LEVEL = 0,
    MOVE = 1,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType] = &[
            ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL,
            ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType>("ZigBeeMsg.ZCLCmd.LevelCmd.ZCLLevelCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType::MOVE_TO_LEVEL
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_LevelCmd_ZCLLevelCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_ColorControlCmd {
    // message fields
    pub field_type: ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType,
    pub movetohue_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams>,
    pub movetosat_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams>,
    pub movetohueandsat_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams>,
    pub movetocolortemp_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_ColorControlCmd {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_ColorControlCmd {
        <ZigBeeMsg_ZCLCmd_ColorControlCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_ColorControlCmd {
    pub fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.ZCLColorControlCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueCmdParams movetohue_params = 2;


    pub fn get_movetohue_params(&self) -> &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        self.movetohue_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_movetohue_params(&mut self) {
        self.movetohue_params.clear();
    }

    pub fn has_movetohue_params(&self) -> bool {
        self.movetohue_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movetohue_params(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams) {
        self.movetohue_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movetohue_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        if self.movetohue_params.is_none() {
            self.movetohue_params.set_default();
        }
        self.movetohue_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_movetohue_params(&mut self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        self.movetohue_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToSatCmdParams movetosat_params = 3;


    pub fn get_movetosat_params(&self) -> &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        self.movetosat_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_movetosat_params(&mut self) {
        self.movetosat_params.clear();
    }

    pub fn has_movetosat_params(&self) -> bool {
        self.movetosat_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movetosat_params(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams) {
        self.movetosat_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movetosat_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        if self.movetosat_params.is_none() {
            self.movetosat_params.set_default();
        }
        self.movetosat_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_movetosat_params(&mut self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        self.movetosat_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueAndSatCmdParams movetohueandsat_params = 4;


    pub fn get_movetohueandsat_params(&self) -> &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        self.movetohueandsat_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_movetohueandsat_params(&mut self) {
        self.movetohueandsat_params.clear();
    }

    pub fn has_movetohueandsat_params(&self) -> bool {
        self.movetohueandsat_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movetohueandsat_params(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams) {
        self.movetohueandsat_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movetohueandsat_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        if self.movetohueandsat_params.is_none() {
            self.movetohueandsat_params.set_default();
        }
        self.movetohueandsat_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_movetohueandsat_params(&mut self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        self.movetohueandsat_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToColorTempCmdParams movetocolortemp_params = 5;


    pub fn get_movetocolortemp_params(&self) -> &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        self.movetocolortemp_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_movetocolortemp_params(&mut self) {
        self.movetocolortemp_params.clear();
    }

    pub fn has_movetocolortemp_params(&self) -> bool {
        self.movetocolortemp_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movetocolortemp_params(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams) {
        self.movetocolortemp_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movetocolortemp_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        if self.movetocolortemp_params.is_none() {
            self.movetocolortemp_params.set_default();
        }
        self.movetocolortemp_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_movetocolortemp_params(&mut self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        self.movetocolortemp_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_ColorControlCmd {
    fn is_initialized(&self) -> bool {
        for v in &self.movetohue_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.movetosat_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.movetohueandsat_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.movetocolortemp_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.movetohue_params)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.movetosat_params)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.movetohueandsat_params)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.movetocolortemp_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.movetohue_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.movetosat_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.movetohueandsat_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.movetocolortemp_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.movetohue_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.movetosat_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.movetohueandsat_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.movetocolortemp_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd {
        ZigBeeMsg_ZCLCmd_ColorControlCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType>>(
                "type",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams>>(
                "movetohue_params",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd| { &m.movetohue_params },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd| { &mut m.movetohue_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams>>(
                "movetosat_params",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd| { &m.movetosat_params },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd| { &mut m.movetosat_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams>>(
                "movetohueandsat_params",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd| { &m.movetohueandsat_params },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd| { &mut m.movetohueandsat_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams>>(
                "movetocolortemp_params",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd| { &m.movetocolortemp_params },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd| { &mut m.movetocolortemp_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd>(
                "ZigBeeMsg.ZCLCmd.ColorControlCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_ColorControlCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_ColorControlCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_ColorControlCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_ColorControlCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE;
        self.movetohue_params.clear();
        self.movetosat_params.clear();
        self.movetohueandsat_params.clear();
        self.movetocolortemp_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_ColorControlCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    // message fields
    pub hue: u32,
    pub direction: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam,
    pub transition_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        ::std::default::Default::default()
    }

    // uint32 hue = 1;


    pub fn get_hue(&self) -> u32 {
        self.hue
    }
    pub fn clear_hue(&mut self) {
        self.hue = 0;
    }

    // Param is passed by value, moved
    pub fn set_hue(&mut self, v: u32) {
        self.hue = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueCmdParams.DirectionParam direction = 2;


    pub fn get_direction(&self) -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam) {
        self.direction = v;
    }

    // uint32 transition_time = 3;


    pub fn get_transition_time(&self) -> u32 {
        self.transition_time
    }
    pub fn clear_transition_time(&mut self) {
        self.transition_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_time(&mut self, v: u32) {
        self.transition_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hue = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hue != 0 {
            my_size += ::protobuf::rt::value_size(1, self.hue, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.direction != ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE {
            my_size += ::protobuf::rt::enum_size(2, self.direction);
        }
        if self.transition_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.transition_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hue != 0 {
            os.write_uint32(1, self.hue)?;
        }
        if self.direction != ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        if self.transition_time != 0 {
            os.write_uint32(3, self.transition_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hue",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &m.hue },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &mut m.hue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam>>(
                "direction",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &m.direction },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_time",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &m.transition_time },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams| { &mut m.transition_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams>(
                "ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    fn clear(&mut self) {
        self.hue = 0;
        self.direction = ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE;
        self.transition_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
    SHORTEST_DISTANCE = 0,
    LONGEST_DISTANCE = 1,
    UP = 2,
    DOWN = 3,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::LONGEST_DISTANCE),
            2 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::UP),
            3 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam] = &[
            ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::LONGEST_DISTANCE,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::UP,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::DOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam>("ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueCmdParams.DirectionParam", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam::SHORTEST_DISTANCE
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueCmdParams_DirectionParam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    // message fields
    pub saturation: u32,
    pub transition_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        ::std::default::Default::default()
    }

    // uint32 saturation = 1;


    pub fn get_saturation(&self) -> u32 {
        self.saturation
    }
    pub fn clear_saturation(&mut self) {
        self.saturation = 0;
    }

    // Param is passed by value, moved
    pub fn set_saturation(&mut self, v: u32) {
        self.saturation = v;
    }

    // uint32 transition_time = 2;


    pub fn get_transition_time(&self) -> u32 {
        self.transition_time
    }
    pub fn clear_transition_time(&mut self) {
        self.transition_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_time(&mut self, v: u32) {
        self.transition_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.saturation = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.saturation != 0 {
            my_size += ::protobuf::rt::value_size(1, self.saturation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.transition_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.transition_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.saturation != 0 {
            os.write_uint32(1, self.saturation)?;
        }
        if self.transition_time != 0 {
            os.write_uint32(2, self.transition_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "saturation",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams| { &m.saturation },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams| { &mut m.saturation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_time",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams| { &m.transition_time },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams| { &mut m.transition_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams>(
                "ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToSatCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    fn clear(&mut self) {
        self.saturation = 0;
        self.transition_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToSatCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    // message fields
    pub hue: u32,
    pub saturation: u32,
    pub transition_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        ::std::default::Default::default()
    }

    // uint32 hue = 1;


    pub fn get_hue(&self) -> u32 {
        self.hue
    }
    pub fn clear_hue(&mut self) {
        self.hue = 0;
    }

    // Param is passed by value, moved
    pub fn set_hue(&mut self, v: u32) {
        self.hue = v;
    }

    // uint32 saturation = 2;


    pub fn get_saturation(&self) -> u32 {
        self.saturation
    }
    pub fn clear_saturation(&mut self) {
        self.saturation = 0;
    }

    // Param is passed by value, moved
    pub fn set_saturation(&mut self, v: u32) {
        self.saturation = v;
    }

    // uint32 transition_time = 3;


    pub fn get_transition_time(&self) -> u32 {
        self.transition_time
    }
    pub fn clear_transition_time(&mut self) {
        self.transition_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_time(&mut self, v: u32) {
        self.transition_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hue = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.saturation = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hue != 0 {
            my_size += ::protobuf::rt::value_size(1, self.hue, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.saturation != 0 {
            my_size += ::protobuf::rt::value_size(2, self.saturation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.transition_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.transition_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hue != 0 {
            os.write_uint32(1, self.hue)?;
        }
        if self.saturation != 0 {
            os.write_uint32(2, self.saturation)?;
        }
        if self.transition_time != 0 {
            os.write_uint32(3, self.transition_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hue",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &m.hue },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &mut m.hue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "saturation",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &m.saturation },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &mut m.saturation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_time",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &m.transition_time },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams| { &mut m.transition_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams>(
                "ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueAndSatCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    fn clear(&mut self) {
        self.hue = 0;
        self.saturation = 0;
        self.transition_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToHueAndSatCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    // message fields
    pub color_temperature: u32,
    pub transition_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        <ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        ::std::default::Default::default()
    }

    // uint32 color_temperature = 1;


    pub fn get_color_temperature(&self) -> u32 {
        self.color_temperature
    }
    pub fn clear_color_temperature(&mut self) {
        self.color_temperature = 0;
    }

    // Param is passed by value, moved
    pub fn set_color_temperature(&mut self, v: u32) {
        self.color_temperature = v;
    }

    // uint32 transition_time = 2;


    pub fn get_transition_time(&self) -> u32 {
        self.transition_time
    }
    pub fn clear_transition_time(&mut self) {
        self.transition_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_time(&mut self, v: u32) {
        self.transition_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color_temperature = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.color_temperature != 0 {
            my_size += ::protobuf::rt::value_size(1, self.color_temperature, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.transition_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.transition_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.color_temperature != 0 {
            os.write_uint32(1, self.color_temperature)?;
        }
        if self.transition_time != 0 {
            os.write_uint32(2, self.transition_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "color_temperature",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams| { &m.color_temperature },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams| { &mut m.color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_time",
                |m: &ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams| { &m.transition_time },
                |m: &mut ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams| { &mut m.transition_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams>(
                "ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToColorTempCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    fn clear(&mut self) {
        self.color_temperature = 0;
        self.transition_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_MoveToColorTempCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
    MOVETOHUE = 0,
    MOVETOSAT = 1,
    MOVETOHUEANDSAT = 2,
    MOVETOCOLORTEMP = 3,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOSAT),
            2 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUEANDSAT),
            3 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOCOLORTEMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType] = &[
            ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOSAT,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUEANDSAT,
            ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOCOLORTEMP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType>("ZigBeeMsg.ZCLCmd.ColorControlCmd.ZCLColorControlCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType::MOVETOHUE
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ColorControlCmd_ZCLColorControlCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_IdentifyCmd {
    // message fields
    pub field_type: ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType,
    pub identify_on_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams>,
    pub identify_off_params: ::protobuf::SingularPtrField<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_IdentifyCmd {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_IdentifyCmd {
        <ZigBeeMsg_ZCLCmd_IdentifyCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_IdentifyCmd {
    pub fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.ZCLIdentifyCmdType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOnCmdParams identify_on_params = 2;


    pub fn get_identify_on_params(&self) -> &ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        self.identify_on_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identify_on_params(&mut self) {
        self.identify_on_params.clear();
    }

    pub fn has_identify_on_params(&self) -> bool {
        self.identify_on_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identify_on_params(&mut self, v: ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams) {
        self.identify_on_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identify_on_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        if self.identify_on_params.is_none() {
            self.identify_on_params.set_default();
        }
        self.identify_on_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_identify_on_params(&mut self) -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        self.identify_on_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOffCmdParams identify_off_params = 3;


    pub fn get_identify_off_params(&self) -> &ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        self.identify_off_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identify_off_params(&mut self) {
        self.identify_off_params.clear();
    }

    pub fn has_identify_off_params(&self) -> bool {
        self.identify_off_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identify_off_params(&mut self, v: ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams) {
        self.identify_off_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identify_off_params(&mut self) -> &mut ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        if self.identify_off_params.is_none() {
            self.identify_off_params.set_default();
        }
        self.identify_off_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_identify_off_params(&mut self) -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        self.identify_off_params.take().unwrap_or_else(|| ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_IdentifyCmd {
    fn is_initialized(&self) -> bool {
        for v in &self.identify_on_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identify_off_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identify_on_params)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identify_off_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.identify_on_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.identify_off_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.identify_on_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.identify_off_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd {
        ZigBeeMsg_ZCLCmd_IdentifyCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType>>(
                "type",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams>>(
                "identify_on_params",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd| { &m.identify_on_params },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd| { &mut m.identify_on_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams>>(
                "identify_off_params",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd| { &m.identify_off_params },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd| { &mut m.identify_off_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_IdentifyCmd>(
                "ZigBeeMsg.ZCLCmd.IdentifyCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_IdentifyCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_IdentifyCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_IdentifyCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_IdentifyCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON;
        self.identify_on_params.clear();
        self.identify_off_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_IdentifyCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_IdentifyCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    // message fields
    pub endpoint: u32,
    pub identify_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        <ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        ::std::default::Default::default()
    }

    // uint32 endpoint = 1;


    pub fn get_endpoint(&self) -> u32 {
        self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint = 0;
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: u32) {
        self.endpoint = v;
    }

    // uint32 identify_time = 2;


    pub fn get_identify_time(&self) -> u32 {
        self.identify_time
    }
    pub fn clear_identify_time(&mut self) {
        self.identify_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_identify_time(&mut self, v: u32) {
        self.identify_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.endpoint = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.identify_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.endpoint != 0 {
            my_size += ::protobuf::rt::value_size(1, self.endpoint, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.identify_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.identify_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.endpoint != 0 {
            os.write_uint32(1, self.endpoint)?;
        }
        if self.identify_time != 0 {
            os.write_uint32(2, self.identify_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "endpoint",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams| { &m.endpoint },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "identify_time",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams| { &m.identify_time },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams| { &mut m.identify_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams>(
                "ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOnCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    fn clear(&mut self) {
        self.endpoint = 0;
        self.identify_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOnCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    // message fields
    pub identify_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    fn default() -> &'a ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        <ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    pub fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        ::std::default::Default::default()
    }

    // uint32 identify_time = 1;


    pub fn get_identify_time(&self) -> u32 {
        self.identify_time
    }
    pub fn clear_identify_time(&mut self) {
        self.identify_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_identify_time(&mut self, v: u32) {
        self.identify_time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.identify_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.identify_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.identify_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.identify_time != 0 {
            os.write_uint32(1, self.identify_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "identify_time",
                |m: &ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams| { &m.identify_time },
                |m: &mut ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams| { &mut m.identify_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams>(
                "ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOffCmdParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    fn clear(&mut self) {
        self.identify_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_IdentifyCmd_IdentifyOffCmdParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
    IDENTIFY_ON = 0,
    IDENTIFY_OFF = 1,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_OFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType] = &[
            ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON,
            ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_OFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType>("ZigBeeMsg.ZCLCmd.IdentifyCmd.ZCLIdentifyCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType::IDENTIFY_ON
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_IdentifyCmd_ZCLIdentifyCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZCLCmd_ZCLCmdType {
    ON_OFF = 0,
    LEVEL = 1,
    COLOR_CONTROL = 2,
    IDENTIFY = 3,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZCLCmd_ZCLCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZCLCmd_ZCLCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ZCLCmdType::LEVEL),
            2 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ZCLCmdType::COLOR_CONTROL),
            3 => ::std::option::Option::Some(ZigBeeMsg_ZCLCmd_ZCLCmdType::IDENTIFY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZCLCmd_ZCLCmdType] = &[
            ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF,
            ZigBeeMsg_ZCLCmd_ZCLCmdType::LEVEL,
            ZigBeeMsg_ZCLCmd_ZCLCmdType::COLOR_CONTROL,
            ZigBeeMsg_ZCLCmd_ZCLCmdType::IDENTIFY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZCLCmd_ZCLCmdType>("ZigBeeMsg.ZCLCmd.ZCLCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZCLCmd_ZCLCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZCLCmd_ZCLCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZCLCmd_ZCLCmdType::ON_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZCLCmd_ZCLCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd {
    // message fields
    pub field_type: ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes,
    pub permit_join_params: ::protobuf::SingularPtrField<ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams>,
    pub is_proxy_active: bool,
    pub node_leave_params: ::protobuf::SingularPtrField<ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams>,
    pub node_info: ::protobuf::SingularPtrField<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>,
    pub connected_nodes: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>,
    pub network_status: ::protobuf::SingularPtrField<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd {
        <ZigBeeMsg_NetworkMgmtCmd as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NetworkMgmtCmdTypes type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes) {
        self.field_type = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.PermitJoinParams permit_join_params = 2;


    pub fn get_permit_join_params(&self) -> &ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        self.permit_join_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permit_join_params(&mut self) {
        self.permit_join_params.clear();
    }

    pub fn has_permit_join_params(&self) -> bool {
        self.permit_join_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permit_join_params(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams) {
        self.permit_join_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permit_join_params(&mut self) -> &mut ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        if self.permit_join_params.is_none() {
            self.permit_join_params.set_default();
        }
        self.permit_join_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_permit_join_params(&mut self) -> ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        self.permit_join_params.take().unwrap_or_else(|| ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams::new())
    }

    // bool is_proxy_active = 3;


    pub fn get_is_proxy_active(&self) -> bool {
        self.is_proxy_active
    }
    pub fn clear_is_proxy_active(&mut self) {
        self.is_proxy_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_proxy_active(&mut self, v: bool) {
        self.is_proxy_active = v;
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NodeLeaveNetParams node_leave_params = 4;


    pub fn get_node_leave_params(&self) -> &ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        self.node_leave_params.as_ref().unwrap_or_else(|| <ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node_leave_params(&mut self) {
        self.node_leave_params.clear();
    }

    pub fn has_node_leave_params(&self) -> bool {
        self.node_leave_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_leave_params(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams) {
        self.node_leave_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_leave_params(&mut self) -> &mut ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        if self.node_leave_params.is_none() {
            self.node_leave_params.set_default();
        }
        self.node_leave_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_leave_params(&mut self) -> ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        self.node_leave_params.take().unwrap_or_else(|| ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NodeDescription node_info = 5;


    pub fn get_node_info(&self) -> &ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        self.node_info.as_ref().unwrap_or_else(|| <ZigBeeMsg_NetworkMgmtCmd_NodeDescription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node_info(&mut self) {
        self.node_info.clear();
    }

    pub fn has_node_info(&self) -> bool {
        self.node_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_info(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_NodeDescription) {
        self.node_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_info(&mut self) -> &mut ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        if self.node_info.is_none() {
            self.node_info.set_default();
        }
        self.node_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_info(&mut self) -> ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        self.node_info.take().unwrap_or_else(|| ZigBeeMsg_NetworkMgmtCmd_NodeDescription::new())
    }

    // repeated .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NodeDescription connected_nodes = 6;


    pub fn get_connected_nodes(&self) -> &[ZigBeeMsg_NetworkMgmtCmd_NodeDescription] {
        &self.connected_nodes
    }
    pub fn clear_connected_nodes(&mut self) {
        self.connected_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected_nodes(&mut self, v: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>) {
        self.connected_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connected_nodes(&mut self) -> &mut ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_NodeDescription> {
        &mut self.connected_nodes
    }

    // Take field
    pub fn take_connected_nodes(&mut self) -> ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_NodeDescription> {
        ::std::mem::replace(&mut self.connected_nodes, ::protobuf::RepeatedField::new())
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NetworkStatus network_status = 7;


    pub fn get_network_status(&self) -> &ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        self.network_status.as_ref().unwrap_or_else(|| <ZigBeeMsg_NetworkMgmtCmd_NetworkStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_status(&mut self) {
        self.network_status.clear();
    }

    pub fn has_network_status(&self) -> bool {
        self.network_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_status(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_NetworkStatus) {
        self.network_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_status(&mut self) -> &mut ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        if self.network_status.is_none() {
            self.network_status.set_default();
        }
        self.network_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_status(&mut self) -> ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        self.network_status.take().unwrap_or_else(|| ZigBeeMsg_NetworkMgmtCmd_NetworkStatus::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd {
    fn is_initialized(&self) -> bool {
        for v in &self.permit_join_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node_leave_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connected_nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permit_join_params)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_proxy_active = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node_leave_params)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node_info)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connected_nodes)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.permit_join_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_proxy_active != false {
            my_size += 2;
        }
        if let Some(ref v) = self.node_leave_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.connected_nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.network_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.permit_join_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_proxy_active != false {
            os.write_bool(3, self.is_proxy_active)?;
        }
        if let Some(ref v) = self.node_leave_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.connected_nodes {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.network_status.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd {
        ZigBeeMsg_NetworkMgmtCmd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes>>(
                "type",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.field_type },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams>>(
                "permit_join_params",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.permit_join_params },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.permit_join_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_proxy_active",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.is_proxy_active },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.is_proxy_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams>>(
                "node_leave_params",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.node_leave_params },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.node_leave_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>>(
                "node_info",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.node_info },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.node_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>>(
                "connected_nodes",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.connected_nodes },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.connected_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus>>(
                "network_status",
                |m: &ZigBeeMsg_NetworkMgmtCmd| { &m.network_status },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd| { &mut m.network_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd>(
                "ZigBeeMsg.NetworkMgmtCmd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK;
        self.permit_join_params.clear();
        self.is_proxy_active = false;
        self.node_leave_params.clear();
        self.node_info.clear();
        self.connected_nodes.clear();
        self.network_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    // message fields
    pub time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        <ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        ::std::default::Default::default()
    }

    // uint32 time = 1;


    pub fn get_time(&self) -> u32 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0 {
            os.write_uint32(1, self.time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time",
                |m: &ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams| { &m.time },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams>(
                "ZigBeeMsg.NetworkMgmtCmd.PermitJoinParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    fn clear(&mut self) {
        self.time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_PermitJoinParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    // message fields
    pub node_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        <ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        ::std::default::Default::default()
    }

    // uint32 node_id = 1;


    pub fn get_node_id(&self) -> u32 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint32(1, self.node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_id",
                |m: &ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams| { &m.node_id },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams| { &mut m.node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams>(
                "ZigBeeMsg.NetworkMgmtCmd.NodeLeaveNetParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    fn clear(&mut self) {
        self.node_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_NodeLeaveNetParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    // message fields
    pub field_type: ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType,
    pub cluster_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
        <ZigBeeMsg_NetworkMgmtCmd_ClusterDescription as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.ClusterDescription.ClusterInOutType type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType) {
        self.field_type = v;
    }

    // uint32 cluster_id = 2;


    pub fn get_cluster_id(&self) -> u32 {
        self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u32) {
        self.cluster_id = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.cluster_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cluster_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.cluster_id != 0 {
            os.write_uint32(2, self.cluster_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
        ZigBeeMsg_NetworkMgmtCmd_ClusterDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType>>(
                "type",
                |m: &ZigBeeMsg_NetworkMgmtCmd_ClusterDescription| { &m.field_type },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_ClusterDescription| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cluster_id",
                |m: &ZigBeeMsg_NetworkMgmtCmd_ClusterDescription| { &m.cluster_id },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_ClusterDescription| { &mut m.cluster_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription>(
                "ZigBeeMsg.NetworkMgmtCmd.ClusterDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_ClusterDescription::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN;
        self.cluster_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
    SERVER_IN = 0,
    CLIENT_OUT = 1,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN),
            1 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::CLIENT_OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType] = &[
            ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN,
            ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::CLIENT_OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType>("ZigBeeMsg.NetworkMgmtCmd.ClusterDescription.ClusterInOutType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
}

impl ::std::default::Default for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
    fn default() -> Self {
        ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType::SERVER_IN
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_ClusterDescription_ClusterInOutType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    // message fields
    pub endpoint_index: u32,
    pub profile_id: u32,
    pub device_id: u32,
    pub clusters: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
        <ZigBeeMsg_NetworkMgmtCmd_EndPointDescription as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
        ::std::default::Default::default()
    }

    // uint32 endpoint_index = 1;


    pub fn get_endpoint_index(&self) -> u32 {
        self.endpoint_index
    }
    pub fn clear_endpoint_index(&mut self) {
        self.endpoint_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_endpoint_index(&mut self, v: u32) {
        self.endpoint_index = v;
    }

    // uint32 profile_id = 2;


    pub fn get_profile_id(&self) -> u32 {
        self.profile_id
    }
    pub fn clear_profile_id(&mut self) {
        self.profile_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_profile_id(&mut self, v: u32) {
        self.profile_id = v;
    }

    // uint32 device_id = 3;


    pub fn get_device_id(&self) -> u32 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u32) {
        self.device_id = v;
    }

    // repeated .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.ClusterDescription clusters = 4;


    pub fn get_clusters(&self) -> &[ZigBeeMsg_NetworkMgmtCmd_ClusterDescription] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.endpoint_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.profile_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.device_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.endpoint_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.endpoint_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.profile_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.profile_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.endpoint_index != 0 {
            os.write_uint32(1, self.endpoint_index)?;
        }
        if self.profile_id != 0 {
            os.write_uint32(2, self.profile_id)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        for v in &self.clusters {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
        ZigBeeMsg_NetworkMgmtCmd_EndPointDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "endpoint_index",
                |m: &ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &m.endpoint_index },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &mut m.endpoint_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "profile_id",
                |m: &ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &m.profile_id },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &mut m.profile_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "device_id",
                |m: &ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &m.device_id },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_ClusterDescription>>(
                "clusters",
                |m: &ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &m.clusters },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_EndPointDescription| { &mut m.clusters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription>(
                "ZigBeeMsg.NetworkMgmtCmd.EndPointDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_EndPointDescription::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    fn clear(&mut self) {
        self.endpoint_index = 0;
        self.profile_id = 0;
        self.device_id = 0;
        self.clusters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_EndPointDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    // message fields
    pub node_id: u32,
    pub eui64: u64,
    pub endpoints: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        <ZigBeeMsg_NetworkMgmtCmd_NodeDescription as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        ::std::default::Default::default()
    }

    // uint32 node_id = 1;


    pub fn get_node_id(&self) -> u32 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = v;
    }

    // uint64 eui64 = 2;


    pub fn get_eui64(&self) -> u64 {
        self.eui64
    }
    pub fn clear_eui64(&mut self) {
        self.eui64 = 0;
    }

    // Param is passed by value, moved
    pub fn set_eui64(&mut self, v: u64) {
        self.eui64 = v;
    }

    // repeated .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.EndPointDescription endpoints = 3;


    pub fn get_endpoints(&self) -> &[ZigBeeMsg_NetworkMgmtCmd_EndPointDescription] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.endpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.eui64 = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.eui64 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.eui64, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.endpoints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint32(1, self.node_id)?;
        }
        if self.eui64 != 0 {
            os.write_uint64(2, self.eui64)?;
        }
        for v in &self.endpoints {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        ZigBeeMsg_NetworkMgmtCmd_NodeDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_id",
                |m: &ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &m.node_id },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "eui64",
                |m: &ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &m.eui64 },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &mut m.eui64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZigBeeMsg_NetworkMgmtCmd_EndPointDescription>>(
                "endpoints",
                |m: &ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &m.endpoints },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_NodeDescription| { &mut m.endpoints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_NodeDescription>(
                "ZigBeeMsg.NetworkMgmtCmd.NodeDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_NodeDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_NodeDescription::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    fn clear(&mut self) {
        self.node_id = 0;
        self.eui64 = 0;
        self.endpoints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_NodeDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    // message fields
    pub field_type: ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    fn default() -> &'a ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        <ZigBeeMsg_NetworkMgmtCmd_NetworkStatus as ::protobuf::Message>::default_instance()
    }
}

impl ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    pub fn new() -> ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NetworkStatus.Status type = 1;


    pub fn get_field_type(&self) -> ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        ZigBeeMsg_NetworkMgmtCmd_NetworkStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status>>(
                "type",
                |m: &ZigBeeMsg_NetworkMgmtCmd_NetworkStatus| { &m.field_type },
                |m: &mut ZigBeeMsg_NetworkMgmtCmd_NetworkStatus| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus>(
                "ZigBeeMsg.NetworkMgmtCmd.NetworkStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
        static instance: ::protobuf::rt::LazyV2<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus::new)
    }
}

impl ::protobuf::Clear for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    fn clear(&mut self) {
        self.field_type = ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
    NO_NETWORK = 0,
    JOINING_NETWORK = 1,
    JOINED_NETWORK = 2,
    JOINED_NETWORK_NO_PARENT = 3,
    LEAVING_NETWORK = 4,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK),
            1 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINING_NETWORK),
            2 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINED_NETWORK),
            3 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINED_NETWORK_NO_PARENT),
            4 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::LEAVING_NETWORK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status] = &[
            ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINING_NETWORK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINED_NETWORK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::JOINED_NETWORK_NO_PARENT,
            ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::LEAVING_NETWORK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status>("ZigBeeMsg.NetworkMgmtCmd.NetworkStatus.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
}

impl ::std::default::Default for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
    fn default() -> Self {
        ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status::NO_NETWORK
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_NetworkStatus_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
    CREATE_NWK = 0,
    LEAVE_NWK = 1,
    NODE_LEAVE_NWK = 2,
    PERMIT_JOIN = 3,
    DISCOVERY_INFO = 4,
    RESET_PROXY = 5,
    IS_PROXY_ACTIVE = 6,
    NETWORK_STATUS = 7,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK),
            1 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::LEAVE_NWK),
            2 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::NODE_LEAVE_NWK),
            3 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::PERMIT_JOIN),
            4 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::DISCOVERY_INFO),
            5 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::RESET_PROXY),
            6 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::IS_PROXY_ACTIVE),
            7 => ::std::option::Option::Some(ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::NETWORK_STATUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes] = &[
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::LEAVE_NWK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::NODE_LEAVE_NWK,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::PERMIT_JOIN,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::DISCOVERY_INFO,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::RESET_PROXY,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::IS_PROXY_ACTIVE,
            ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::NETWORK_STATUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes>("ZigBeeMsg.NetworkMgmtCmd.NetworkMgmtCmdTypes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
}

impl ::std::default::Default for ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
    fn default() -> Self {
        ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes::CREATE_NWK
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_NetworkMgmtCmd_NetworkMgmtCmdTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZigBeeMsg_ZigBeeCmdType {
    ZCL = 0,
    NETWORK_MGMT = 1,
}

impl ::protobuf::ProtobufEnum for ZigBeeMsg_ZigBeeCmdType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZigBeeMsg_ZigBeeCmdType> {
        match value {
            0 => ::std::option::Option::Some(ZigBeeMsg_ZigBeeCmdType::ZCL),
            1 => ::std::option::Option::Some(ZigBeeMsg_ZigBeeCmdType::NETWORK_MGMT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZigBeeMsg_ZigBeeCmdType] = &[
            ZigBeeMsg_ZigBeeCmdType::ZCL,
            ZigBeeMsg_ZigBeeCmdType::NETWORK_MGMT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZigBeeMsg_ZigBeeCmdType>("ZigBeeMsg.ZigBeeCmdType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZigBeeMsg_ZigBeeCmdType {
}

impl ::std::default::Default for ZigBeeMsg_ZigBeeCmdType {
    fn default() -> Self {
        ZigBeeMsg_ZigBeeCmdType::ZCL
    }
}

impl ::protobuf::reflect::ProtobufValue for ZigBeeMsg_ZigBeeCmdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZWaveMsg {
    // message fields
    pub operation: ZWaveMsg_ZWaveOperations,
    pub service_to_send: ::std::string::String,
    pub zwave_cmd: ::protobuf::SingularPtrField<ZWaveMsg_ZWaveCommand>,
    pub node: ::protobuf::RepeatedField<ZWaveMsg_ZWaveNode>,
    pub result: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZWaveMsg {
    fn default() -> &'a ZWaveMsg {
        <ZWaveMsg as ::protobuf::Message>::default_instance()
    }
}

impl ZWaveMsg {
    pub fn new() -> ZWaveMsg {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZWaveMsg.ZWaveOperations operation = 1;


    pub fn get_operation(&self) -> ZWaveMsg_ZWaveOperations {
        self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation = ZWaveMsg_ZWaveOperations::UNDEF;
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ZWaveMsg_ZWaveOperations) {
        self.operation = v;
    }

    // string service_to_send = 2;


    pub fn get_service_to_send(&self) -> &str {
        &self.service_to_send
    }
    pub fn clear_service_to_send(&mut self) {
        self.service_to_send.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_to_send(&mut self, v: ::std::string::String) {
        self.service_to_send = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_to_send(&mut self) -> &mut ::std::string::String {
        &mut self.service_to_send
    }

    // Take field
    pub fn take_service_to_send(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_to_send, ::std::string::String::new())
    }

    // .matrix_io.malos.v1.comm.ZWaveMsg.ZWaveCommand zwave_cmd = 3;


    pub fn get_zwave_cmd(&self) -> &ZWaveMsg_ZWaveCommand {
        self.zwave_cmd.as_ref().unwrap_or_else(|| <ZWaveMsg_ZWaveCommand as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zwave_cmd(&mut self) {
        self.zwave_cmd.clear();
    }

    pub fn has_zwave_cmd(&self) -> bool {
        self.zwave_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zwave_cmd(&mut self, v: ZWaveMsg_ZWaveCommand) {
        self.zwave_cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zwave_cmd(&mut self) -> &mut ZWaveMsg_ZWaveCommand {
        if self.zwave_cmd.is_none() {
            self.zwave_cmd.set_default();
        }
        self.zwave_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_zwave_cmd(&mut self) -> ZWaveMsg_ZWaveCommand {
        self.zwave_cmd.take().unwrap_or_else(|| ZWaveMsg_ZWaveCommand::new())
    }

    // repeated .matrix_io.malos.v1.comm.ZWaveMsg.ZWaveNode node = 4;


    pub fn get_node(&self) -> &[ZWaveMsg_ZWaveNode] {
        &self.node
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<ZWaveMsg_ZWaveNode>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<ZWaveMsg_ZWaveNode> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<ZWaveMsg_ZWaveNode> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    // bool result = 5;


    pub fn get_result(&self) -> bool {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }
}

impl ::protobuf::Message for ZWaveMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.zwave_cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_to_send)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zwave_cmd)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.operation != ZWaveMsg_ZWaveOperations::UNDEF {
            my_size += ::protobuf::rt::enum_size(1, self.operation);
        }
        if !self.service_to_send.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_to_send);
        }
        if let Some(ref v) = self.zwave_cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.result != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.operation != ZWaveMsg_ZWaveOperations::UNDEF {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.operation))?;
        }
        if !self.service_to_send.is_empty() {
            os.write_string(2, &self.service_to_send)?;
        }
        if let Some(ref v) = self.zwave_cmd.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.node {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.result != false {
            os.write_bool(5, self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZWaveMsg {
        ZWaveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZWaveMsg_ZWaveOperations>>(
                "operation",
                |m: &ZWaveMsg| { &m.operation },
                |m: &mut ZWaveMsg| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_to_send",
                |m: &ZWaveMsg| { &m.service_to_send },
                |m: &mut ZWaveMsg| { &mut m.service_to_send },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZWaveMsg_ZWaveCommand>>(
                "zwave_cmd",
                |m: &ZWaveMsg| { &m.zwave_cmd },
                |m: &mut ZWaveMsg| { &mut m.zwave_cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZWaveMsg_ZWaveNode>>(
                "node",
                |m: &ZWaveMsg| { &m.node },
                |m: &mut ZWaveMsg| { &mut m.node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &ZWaveMsg| { &m.result },
                |m: &mut ZWaveMsg| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZWaveMsg>(
                "ZWaveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZWaveMsg {
        static instance: ::protobuf::rt::LazyV2<ZWaveMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZWaveMsg::new)
    }
}

impl ::protobuf::Clear for ZWaveMsg {
    fn clear(&mut self) {
        self.operation = ZWaveMsg_ZWaveOperations::UNDEF;
        self.service_to_send.clear();
        self.zwave_cmd.clear();
        self.node.clear();
        self.result = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZWaveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZWaveMsg_ZWaveCommandInfo {
    // message fields
    pub cmd: super::zwave_commands::ZWaveCmdType,
    pub param: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZWaveMsg_ZWaveCommandInfo {
    fn default() -> &'a ZWaveMsg_ZWaveCommandInfo {
        <ZWaveMsg_ZWaveCommandInfo as ::protobuf::Message>::default_instance()
    }
}

impl ZWaveMsg_ZWaveCommandInfo {
    pub fn new() -> ZWaveMsg_ZWaveCommandInfo {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZWaveCmdType cmd = 1;


    pub fn get_cmd(&self) -> super::zwave_commands::ZWaveCmdType {
        self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd = super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: super::zwave_commands::ZWaveCmdType) {
        self.cmd = v;
    }

    // repeated string param = 2;


    pub fn get_param(&self) -> &[::std::string::String] {
        &self.param
    }
    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.param = v;
    }

    // Mutable pointer to the field.
    pub fn mut_param(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.param
    }

    // Take field
    pub fn take_param(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.param, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZWaveMsg_ZWaveCommandInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cmd, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.param)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cmd != super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.cmd);
        }
        for value in &self.param {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cmd != super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.cmd))?;
        }
        for v in &self.param {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZWaveMsg_ZWaveCommandInfo {
        ZWaveMsg_ZWaveCommandInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::zwave_commands::ZWaveCmdType>>(
                "cmd",
                |m: &ZWaveMsg_ZWaveCommandInfo| { &m.cmd },
                |m: &mut ZWaveMsg_ZWaveCommandInfo| { &mut m.cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "param",
                |m: &ZWaveMsg_ZWaveCommandInfo| { &m.param },
                |m: &mut ZWaveMsg_ZWaveCommandInfo| { &mut m.param },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZWaveMsg_ZWaveCommandInfo>(
                "ZWaveMsg.ZWaveCommandInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZWaveMsg_ZWaveCommandInfo {
        static instance: ::protobuf::rt::LazyV2<ZWaveMsg_ZWaveCommandInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZWaveMsg_ZWaveCommandInfo::new)
    }
}

impl ::protobuf::Clear for ZWaveMsg_ZWaveCommandInfo {
    fn clear(&mut self) {
        self.cmd = super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED;
        self.param.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZWaveMsg_ZWaveCommandInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg_ZWaveCommandInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZWaveMsg_ZWaveClassInfo {
    // message fields
    pub zwave_class: super::zwave_commands::ZWaveClassType,
    pub command: ::protobuf::RepeatedField<ZWaveMsg_ZWaveCommandInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZWaveMsg_ZWaveClassInfo {
    fn default() -> &'a ZWaveMsg_ZWaveClassInfo {
        <ZWaveMsg_ZWaveClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl ZWaveMsg_ZWaveClassInfo {
    pub fn new() -> ZWaveMsg_ZWaveClassInfo {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZWaveClassType zwave_class = 1;


    pub fn get_zwave_class(&self) -> super::zwave_commands::ZWaveClassType {
        self.zwave_class
    }
    pub fn clear_zwave_class(&mut self) {
        self.zwave_class = super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION;
    }

    // Param is passed by value, moved
    pub fn set_zwave_class(&mut self, v: super::zwave_commands::ZWaveClassType) {
        self.zwave_class = v;
    }

    // repeated .matrix_io.malos.v1.comm.ZWaveMsg.ZWaveCommandInfo command = 2;


    pub fn get_command(&self) -> &[ZWaveMsg_ZWaveCommandInfo] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<ZWaveMsg_ZWaveCommandInfo>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<ZWaveMsg_ZWaveCommandInfo> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<ZWaveMsg_ZWaveCommandInfo> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZWaveMsg_ZWaveClassInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.zwave_class, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.zwave_class != super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION {
            my_size += ::protobuf::rt::enum_size(1, self.zwave_class);
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.zwave_class != super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.zwave_class))?;
        }
        for v in &self.command {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZWaveMsg_ZWaveClassInfo {
        ZWaveMsg_ZWaveClassInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::zwave_commands::ZWaveClassType>>(
                "zwave_class",
                |m: &ZWaveMsg_ZWaveClassInfo| { &m.zwave_class },
                |m: &mut ZWaveMsg_ZWaveClassInfo| { &mut m.zwave_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZWaveMsg_ZWaveCommandInfo>>(
                "command",
                |m: &ZWaveMsg_ZWaveClassInfo| { &m.command },
                |m: &mut ZWaveMsg_ZWaveClassInfo| { &mut m.command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZWaveMsg_ZWaveClassInfo>(
                "ZWaveMsg.ZWaveClassInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZWaveMsg_ZWaveClassInfo {
        static instance: ::protobuf::rt::LazyV2<ZWaveMsg_ZWaveClassInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZWaveMsg_ZWaveClassInfo::new)
    }
}

impl ::protobuf::Clear for ZWaveMsg_ZWaveClassInfo {
    fn clear(&mut self) {
        self.zwave_class = super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION;
        self.command.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZWaveMsg_ZWaveClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg_ZWaveClassInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZWaveMsg_ZWaveNode {
    // message fields
    pub service_name: ::std::string::String,
    pub zwave_class: ::protobuf::RepeatedField<ZWaveMsg_ZWaveClassInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZWaveMsg_ZWaveNode {
    fn default() -> &'a ZWaveMsg_ZWaveNode {
        <ZWaveMsg_ZWaveNode as ::protobuf::Message>::default_instance()
    }
}

impl ZWaveMsg_ZWaveNode {
    pub fn new() -> ZWaveMsg_ZWaveNode {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // repeated .matrix_io.malos.v1.comm.ZWaveMsg.ZWaveClassInfo zwave_class = 2;


    pub fn get_zwave_class(&self) -> &[ZWaveMsg_ZWaveClassInfo] {
        &self.zwave_class
    }
    pub fn clear_zwave_class(&mut self) {
        self.zwave_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_zwave_class(&mut self, v: ::protobuf::RepeatedField<ZWaveMsg_ZWaveClassInfo>) {
        self.zwave_class = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zwave_class(&mut self) -> &mut ::protobuf::RepeatedField<ZWaveMsg_ZWaveClassInfo> {
        &mut self.zwave_class
    }

    // Take field
    pub fn take_zwave_class(&mut self) -> ::protobuf::RepeatedField<ZWaveMsg_ZWaveClassInfo> {
        ::std::mem::replace(&mut self.zwave_class, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZWaveMsg_ZWaveNode {
    fn is_initialized(&self) -> bool {
        for v in &self.zwave_class {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.zwave_class)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        for value in &self.zwave_class {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        for v in &self.zwave_class {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZWaveMsg_ZWaveNode {
        ZWaveMsg_ZWaveNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ZWaveMsg_ZWaveNode| { &m.service_name },
                |m: &mut ZWaveMsg_ZWaveNode| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZWaveMsg_ZWaveClassInfo>>(
                "zwave_class",
                |m: &ZWaveMsg_ZWaveNode| { &m.zwave_class },
                |m: &mut ZWaveMsg_ZWaveNode| { &mut m.zwave_class },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZWaveMsg_ZWaveNode>(
                "ZWaveMsg.ZWaveNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZWaveMsg_ZWaveNode {
        static instance: ::protobuf::rt::LazyV2<ZWaveMsg_ZWaveNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZWaveMsg_ZWaveNode::new)
    }
}

impl ::protobuf::Clear for ZWaveMsg_ZWaveNode {
    fn clear(&mut self) {
        self.service_name.clear();
        self.zwave_class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZWaveMsg_ZWaveNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg_ZWaveNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZWaveMsg_ZWaveCommand {
    // message fields
    pub zwclass: super::zwave_commands::ZWaveClassType,
    pub cmd: super::zwave_commands::ZWaveCmdType,
    pub params: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZWaveMsg_ZWaveCommand {
    fn default() -> &'a ZWaveMsg_ZWaveCommand {
        <ZWaveMsg_ZWaveCommand as ::protobuf::Message>::default_instance()
    }
}

impl ZWaveMsg_ZWaveCommand {
    pub fn new() -> ZWaveMsg_ZWaveCommand {
        ::std::default::Default::default()
    }

    // .matrix_io.malos.v1.comm.ZWaveClassType zwclass = 1;


    pub fn get_zwclass(&self) -> super::zwave_commands::ZWaveClassType {
        self.zwclass
    }
    pub fn clear_zwclass(&mut self) {
        self.zwclass = super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION;
    }

    // Param is passed by value, moved
    pub fn set_zwclass(&mut self, v: super::zwave_commands::ZWaveClassType) {
        self.zwclass = v;
    }

    // .matrix_io.malos.v1.comm.ZWaveCmdType cmd = 2;


    pub fn get_cmd(&self) -> super::zwave_commands::ZWaveCmdType {
        self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd = super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: super::zwave_commands::ZWaveCmdType) {
        self.cmd = v;
    }

    // bytes params = 3;


    pub fn get_params(&self) -> &[u8] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::vec::Vec<u8>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.params, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ZWaveMsg_ZWaveCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.zwclass, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cmd, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.zwclass != super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION {
            my_size += ::protobuf::rt::enum_size(1, self.zwclass);
        }
        if self.cmd != super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(2, self.cmd);
        }
        if !self.params.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.params);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.zwclass != super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.zwclass))?;
        }
        if self.cmd != super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.cmd))?;
        }
        if !self.params.is_empty() {
            os.write_bytes(3, &self.params)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZWaveMsg_ZWaveCommand {
        ZWaveMsg_ZWaveCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::zwave_commands::ZWaveClassType>>(
                "zwclass",
                |m: &ZWaveMsg_ZWaveCommand| { &m.zwclass },
                |m: &mut ZWaveMsg_ZWaveCommand| { &mut m.zwclass },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::zwave_commands::ZWaveCmdType>>(
                "cmd",
                |m: &ZWaveMsg_ZWaveCommand| { &m.cmd },
                |m: &mut ZWaveMsg_ZWaveCommand| { &mut m.cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "params",
                |m: &ZWaveMsg_ZWaveCommand| { &m.params },
                |m: &mut ZWaveMsg_ZWaveCommand| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZWaveMsg_ZWaveCommand>(
                "ZWaveMsg.ZWaveCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZWaveMsg_ZWaveCommand {
        static instance: ::protobuf::rt::LazyV2<ZWaveMsg_ZWaveCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZWaveMsg_ZWaveCommand::new)
    }
}

impl ::protobuf::Clear for ZWaveMsg_ZWaveCommand {
    fn clear(&mut self) {
        self.zwclass = super::zwave_commands::ZWaveClassType::COMMAND_CLASS_NO_OPERATION;
        self.cmd = super::zwave_commands::ZWaveCmdType::CMD_UNDEFINED;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZWaveMsg_ZWaveCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg_ZWaveCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZWaveMsg_ZWaveOperations {
    UNDEF = 0,
    SEND = 1,
    ADDNODE = 2,
    REMOVENODE = 3,
    SETDEFAULT = 4,
    LIST = 5,
}

impl ::protobuf::ProtobufEnum for ZWaveMsg_ZWaveOperations {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZWaveMsg_ZWaveOperations> {
        match value {
            0 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::UNDEF),
            1 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::SEND),
            2 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::ADDNODE),
            3 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::REMOVENODE),
            4 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::SETDEFAULT),
            5 => ::std::option::Option::Some(ZWaveMsg_ZWaveOperations::LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZWaveMsg_ZWaveOperations] = &[
            ZWaveMsg_ZWaveOperations::UNDEF,
            ZWaveMsg_ZWaveOperations::SEND,
            ZWaveMsg_ZWaveOperations::ADDNODE,
            ZWaveMsg_ZWaveOperations::REMOVENODE,
            ZWaveMsg_ZWaveOperations::SETDEFAULT,
            ZWaveMsg_ZWaveOperations::LIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZWaveMsg_ZWaveOperations>("ZWaveMsg.ZWaveOperations", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZWaveMsg_ZWaveOperations {
}

impl ::std::default::Default for ZWaveMsg_ZWaveOperations {
    fn default() -> Self {
        ZWaveMsg_ZWaveOperations::UNDEF
    }
}

impl ::protobuf::reflect::ProtobufValue for ZWaveMsg_ZWaveOperations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LircParams {
    // message fields
    pub device: ::std::string::String,
    pub command: ::std::string::String,
    pub config: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LircParams {
    fn default() -> &'a LircParams {
        <LircParams as ::protobuf::Message>::default_instance()
    }
}

impl LircParams {
    pub fn new() -> LircParams {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // string command = 2;


    pub fn get_command(&self) -> &str {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.command, ::std::string::String::new())
    }

    // string config = 3;


    pub fn get_config(&self) -> &str {
        &self.config
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::string::String) {
        self.config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::std::string::String {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.config, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LircParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if !self.command.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.command);
        }
        if !self.config.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.config);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if !self.command.is_empty() {
            os.write_string(2, &self.command)?;
        }
        if !self.config.is_empty() {
            os.write_string(3, &self.config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LircParams {
        LircParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &LircParams| { &m.device },
                |m: &mut LircParams| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &LircParams| { &m.command },
                |m: &mut LircParams| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "config",
                |m: &LircParams| { &m.config },
                |m: &mut LircParams| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LircParams>(
                "LircParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LircParams {
        static instance: ::protobuf::rt::LazyV2<LircParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LircParams::new)
    }
}

impl ::protobuf::Clear for LircParams {
    fn clear(&mut self) {
        self.device.clear();
        self.command.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LircParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LircParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dmatrix_io/malos/v1/comm.proto\x12\x17matrix_io.malos.v1.comm\x1a'm\
    atrix_io/malos/v1/zwave_commands.proto\"\x8d*\n\tZigBeeMsg\x12F\n\x04typ\
    e\x18\x01\x20\x01(\x0e20.matrix_io.malos.v1.comm.ZigBeeMsg.ZigBeeCmdType\
    R\x04typeB\0\x12D\n\x07zcl_cmd\x18\x02\x20\x01(\x0b2).matrix_io.malos.v1\
    .comm.ZigBeeMsg.ZCLCmdR\x06zclCmdB\0\x12]\n\x10network_mgmt_cmd\x18\x03\
    \x20\x01(\x0b21.matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmdR\x0enet\
    workMgmtCmdB\0\x1a\xbc\x19\n\x06ZCLCmd\x12J\n\x04type\x18\x01\x20\x01(\
    \x0e24.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ZCLCmdTypeR\x04typeB\0\
    \x12Q\n\tonoff_cmd\x18\x02\x20\x01(\x0b22.matrix_io.malos.v1.comm.ZigBee\
    Msg.ZCLCmd.OnOffCmdR\x08onoffCmdB\0\x12Q\n\tlevel_cmd\x18\x03\x20\x01(\
    \x0b22.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmdR\x08levelCmdB\0\
    \x12f\n\x10colorcontrol_cmd\x18\x04\x20\x01(\x0b29.matrix_io.malos.v1.co\
    mm.ZigBeeMsg.ZCLCmd.ColorControlCmdR\x0fcolorcontrolCmdB\0\x12Z\n\x0cide\
    ntify_cmd\x18\x05\x20\x01(\x0b25.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCm\
    d.IdentifyCmdR\x0bidentifyCmdB\0\x12\x19\n\x07node_id\x18\x06\x20\x01(\r\
    R\x06nodeIdB\0\x12'\n\x0eendpoint_index\x18\x07\x20\x01(\rR\rendpointInd\
    exB\0\x1a\x98\x01\n\x08OnOffCmd\x12X\n\x04type\x18\x01\x20\x01(\x0e2B.ma\
    trix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.OnOffCmd.ZCLOnOffCmdTypeR\x04type\
    B\0\"0\n\x0fZCLOnOffCmdType\x12\x06\n\x02ON\x10\0\x12\x07\n\x03OFF\x10\
    \x01\x12\n\n\x06TOGGLE\x10\x02\x1a\0:\0\x1a\x95\x04\n\x08LevelCmd\x12X\n\
    \x04type\x18\x01\x20\x01(\x0e2B.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd\
    .LevelCmd.ZCLLevelCmdTypeR\x04typeB\0\x12z\n\x14move_to_level_params\x18\
    \x02\x20\x01(\x0b2G.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd.Mo\
    veToLevelCmdParamsR\x11moveToLevelParamsB\0\x12c\n\x0bmove_params\x18\
    \x03\x20\x01(\x0b2@.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.LevelCmd.Mo\
    veCmdParamsR\nmoveParamsB\0\x1a[\n\x14MoveToLevelCmdParams\x12\x16\n\x05\
    level\x18\x01\x20\x01(\rR\x05levelB\0\x12)\n\x0ftransition_time\x18\x02\
    \x20\x01(\rR\x0etransitionTimeB\0:\0\x1a=\n\rMoveCmdParams\x12\x14\n\x04\
    mode\x18\x01\x20\x01(\rR\x04modeB\0\x12\x14\n\x04rate\x18\x02\x20\x01(\r\
    R\x04rateB\0:\0\"0\n\x0fZCLLevelCmdType\x12\x11\n\rMOVE_TO_LEVEL\x10\0\
    \x12\x08\n\x04MOVE\x10\x01\x1a\0:\0\x1a\xf5\n\n\x0fColorControlCmd\x12f\
    \n\x04type\x18\x01\x20\x01(\x0e2P.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLC\
    md.ColorControlCmd.ZCLColorControlCmdTypeR\x04typeB\0\x12y\n\x10movetohu\
    e_params\x18\x02\x20\x01(\x0b2L.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd\
    .ColorControlCmd.MoveToHueCmdParamsR\x0fmovetohueParamsB\0\x12y\n\x10mov\
    etosat_params\x18\x03\x20\x01(\x0b2L.matrix_io.malos.v1.comm.ZigBeeMsg.Z\
    CLCmd.ColorControlCmd.MoveToSatCmdParamsR\x0fmovetosatParamsB\0\x12\x8b\
    \x01\n\x16movetohueandsat_params\x18\x04\x20\x01(\x0b2R.matrix_io.malos.\
    v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd.MoveToHueAndSatCmdParamsR\x15mo\
    vetohueandsatParamsB\0\x12\x8b\x01\n\x16movetocolortemp_params\x18\x05\
    \x20\x01(\x0b2R.matrix_io.malos.v1.comm.ZigBeeMsg.ZCLCmd.ColorControlCmd\
    .MoveToColorTempCmdParamsR\x15movetocolortempParamsB\0\x1a\xa5\x02\n\x12\
    MoveToHueCmdParams\x12\x12\n\x03hue\x18\x01\x20\x01(\rR\x03hueB\0\x12{\n\
    \tdirection\x18\x02\x20\x01(\x0e2[.matrix_io.malos.v1.comm.ZigBeeMsg.ZCL\
    Cmd.ColorControlCmd.MoveToHueCmdParams.DirectionParamR\tdirectionB\0\x12\
    )\n\x0ftransition_time\x18\x03\x20\x01(\rR\x0etransitionTimeB\0\"Q\n\x0e\
    DirectionParam\x12\x15\n\x11SHORTEST_DISTANCE\x10\0\x12\x14\n\x10LONGEST\
    _DISTANCE\x10\x01\x12\x06\n\x02UP\x10\x02\x12\x08\n\x04DOWN\x10\x03\x1a\
    \0:\0\x1ac\n\x12MoveToSatCmdParams\x12\x20\n\nsaturation\x18\x01\x20\x01\
    (\rR\nsaturationB\0\x12)\n\x0ftransition_time\x18\x02\x20\x01(\rR\x0etra\
    nsitionTimeB\0:\0\x1a}\n\x18MoveToHueAndSatCmdParams\x12\x12\n\x03hue\
    \x18\x01\x20\x01(\rR\x03hueB\0\x12\x20\n\nsaturation\x18\x02\x20\x01(\rR\
    \nsaturationB\0\x12)\n\x0ftransition_time\x18\x03\x20\x01(\rR\x0etransit\
    ionTimeB\0:\0\x1av\n\x18MoveToColorTempCmdParams\x12-\n\x11color_tempera\
    ture\x18\x01\x20\x01(\rR\x10colorTemperatureB\0\x12)\n\x0ftransition_tim\
    e\x18\x02\x20\x01(\rR\x0etransitionTimeB\0:\0\"b\n\x16ZCLColorControlCmd\
    Type\x12\r\n\tMOVETOHUE\x10\0\x12\r\n\tMOVETOSAT\x10\x01\x12\x13\n\x0fMO\
    VETOHUEANDSAT\x10\x02\x12\x13\n\x0fMOVETOCOLORTEMP\x10\x03\x1a\0:\0\x1a\
    \xc2\x04\n\x0bIdentifyCmd\x12^\n\x04type\x18\x01\x20\x01(\x0e2H.matrix_i\
    o.malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.ZCLIdentifyCmdTypeR\x04type\
    B\0\x12y\n\x12identify_on_params\x18\x02\x20\x01(\x0b2I.matrix_io.malos.\
    v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOnCmdParamsR\x10identifyOnP\
    aramsB\0\x12|\n\x13identify_off_params\x18\x03\x20\x01(\x0b2J.matrix_io.\
    malos.v1.comm.ZigBeeMsg.ZCLCmd.IdentifyCmd.IdentifyOffCmdParamsR\x11iden\
    tifyOffParamsB\0\x1a\\\n\x13IdentifyOnCmdParams\x12\x1c\n\x08endpoint\
    \x18\x01\x20\x01(\rR\x08endpointB\0\x12%\n\ridentify_time\x18\x02\x20\
    \x01(\rR\x0cidentifyTimeB\0:\0\x1a?\n\x14IdentifyOffCmdParams\x12%\n\rid\
    entify_time\x18\x01\x20\x01(\rR\x0cidentifyTimeB\0:\0\"9\n\x12ZCLIdentif\
    yCmdType\x12\x0f\n\x0bIDENTIFY_ON\x10\0\x12\x10\n\x0cIDENTIFY_OFF\x10\
    \x01\x1a\0:\0\"F\n\nZCLCmdType\x12\n\n\x06ON_OFF\x10\0\x12\t\n\x05LEVEL\
    \x10\x01\x12\x11\n\rCOLOR_CONTROL\x10\x02\x12\x0c\n\x08IDENTIFY\x10\x03\
    \x1a\0:\0\x1a\xa3\x0e\n\x0eNetworkMgmtCmd\x12[\n\x04type\x18\x01\x20\x01\
    (\x0e2E.matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NetworkMgmtCmdT\
    ypesR\x04typeB\0\x12r\n\x12permit_join_params\x18\x02\x20\x01(\x0b2B.mat\
    rix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.PermitJoinParamsR\x10permi\
    tJoinParamsB\0\x12(\n\x0fis_proxy_active\x18\x03\x20\x01(\x08R\risProxyA\
    ctiveB\0\x12r\n\x11node_leave_params\x18\x04\x20\x01(\x0b2D.matrix_io.ma\
    los.v1.comm.ZigBeeMsg.NetworkMgmtCmd.NodeLeaveNetParamsR\x0fnodeLeavePar\
    amsB\0\x12`\n\tnode_info\x18\x05\x20\x01(\x0b2A.matrix_io.malos.v1.comm.\
    ZigBeeMsg.NetworkMgmtCmd.NodeDescriptionR\x08nodeInfoB\0\x12l\n\x0fconne\
    cted_nodes\x18\x06\x20\x03(\x0b2A.matrix_io.malos.v1.comm.ZigBeeMsg.Netw\
    orkMgmtCmd.NodeDescriptionR\x0econnectedNodesB\0\x12h\n\x0enetwork_statu\
    s\x18\x07\x20\x01(\x0b2?.matrix_io.malos.v1.comm.ZigBeeMsg.NetworkMgmtCm\
    d.NetworkStatusR\rnetworkStatusB\0\x1a*\n\x10PermitJoinParams\x12\x14\n\
    \x04time\x18\x01\x20\x01(\rR\x04timeB\0:\0\x1a1\n\x12NodeLeaveNetParams\
    \x12\x19\n\x07node_id\x18\x01\x20\x01(\rR\x06nodeIdB\0:\0\x1a\xd9\x01\n\
    \x12ClusterDescription\x12k\n\x04type\x18\x01\x20\x01(\x0e2U.matrix_io.m\
    alos.v1.comm.ZigBeeMsg.NetworkMgmtCmd.ClusterDescription.ClusterInOutTyp\
    eR\x04typeB\0\x12\x1f\n\ncluster_id\x18\x02\x20\x01(\rR\tclusterIdB\0\"3\
    \n\x10ClusterInOutType\x12\r\n\tSERVER_IN\x10\0\x12\x0e\n\nCLIENT_OUT\
    \x10\x01\x1a\0:\0\x1a\xe4\x01\n\x13EndPointDescription\x12'\n\x0eendpoin\
    t_index\x18\x01\x20\x01(\rR\rendpointIndexB\0\x12\x1f\n\nprofile_id\x18\
    \x02\x20\x01(\rR\tprofileIdB\0\x12\x1d\n\tdevice_id\x18\x03\x20\x01(\rR\
    \x08deviceIdB\0\x12b\n\x08clusters\x18\x04\x20\x03(\x0b2D.matrix_io.malo\
    s.v1.comm.ZigBeeMsg.NetworkMgmtCmd.ClusterDescriptionR\x08clustersB\0:\0\
    \x1a\xad\x01\n\x0fNodeDescription\x12\x19\n\x07node_id\x18\x01\x20\x01(\
    \rR\x06nodeIdB\0\x12\x16\n\x05eui64\x18\x02\x20\x01(\x04R\x05eui64B\0\
    \x12e\n\tendpoints\x18\x03\x20\x03(\x0b2E.matrix_io.malos.v1.comm.ZigBee\
    Msg.NetworkMgmtCmd.EndPointDescriptionR\tendpointsB\0:\0\x1a\xe7\x01\n\r\
    NetworkStatus\x12\\\n\x04type\x18\x01\x20\x01(\x0e2F.matrix_io.malos.v1.\
    comm.ZigBeeMsg.NetworkMgmtCmd.NetworkStatus.StatusR\x04typeB\0\"v\n\x06S\
    tatus\x12\x0e\n\nNO_NETWORK\x10\0\x12\x13\n\x0fJOINING_NETWORK\x10\x01\
    \x12\x12\n\x0eJOINED_NETWORK\x10\x02\x12\x1c\n\x18JOINED_NETWORK_NO_PARE\
    NT\x10\x03\x12\x13\n\x0fLEAVING_NETWORK\x10\x04\x1a\0:\0\"\xa9\x01\n\x13\
    NetworkMgmtCmdTypes\x12\x0e\n\nCREATE_NWK\x10\0\x12\r\n\tLEAVE_NWK\x10\
    \x01\x12\x12\n\x0eNODE_LEAVE_NWK\x10\x02\x12\x0f\n\x0bPERMIT_JOIN\x10\
    \x03\x12\x12\n\x0eDISCOVERY_INFO\x10\x04\x12\x0f\n\x0bRESET_PROXY\x10\
    \x05\x12\x13\n\x0fIS_PROXY_ACTIVE\x10\x06\x12\x12\n\x0eNETWORK_STATUS\
    \x10\x07\x1a\0:\0\",\n\rZigBeeCmdType\x12\x07\n\x03ZCL\x10\0\x12\x10\n\
    \x0cNETWORK_MGMT\x10\x01\x1a\0:\0\"\xe7\x07\n\x08ZWaveMsg\x12Q\n\toperat\
    ion\x18\x01\x20\x01(\x0e21.matrix_io.malos.v1.comm.ZWaveMsg.ZWaveOperati\
    onsR\toperationB\0\x12(\n\x0fservice_to_send\x18\x02\x20\x01(\tR\rservic\
    eToSendB\0\x12M\n\tzwave_cmd\x18\x03\x20\x01(\x0b2..matrix_io.malos.v1.c\
    omm.ZWaveMsg.ZWaveCommandR\x08zwaveCmdB\0\x12A\n\x04node\x18\x04\x20\x03\
    (\x0b2+.matrix_io.malos.v1.comm.ZWaveMsg.ZWaveNodeR\x04nodeB\0\x12\x18\n\
    \x06result\x18\x05\x20\x01(\x08R\x06resultB\0\x1ag\n\x10ZWaveCommandInfo\
    \x129\n\x03cmd\x18\x01\x20\x01(\x0e2%.matrix_io.malos.v1.comm.ZWaveCmdTy\
    peR\x03cmdB\0\x12\x16\n\x05param\x18\x02\x20\x03(\tR\x05paramB\0:\0\x1a\
    \xae\x01\n\x0eZWaveClassInfo\x12J\n\x0bzwave_class\x18\x01\x20\x01(\x0e2\
    '.matrix_io.malos.v1.comm.ZWaveClassTypeR\nzwaveClassB\0\x12N\n\x07comma\
    nd\x18\x02\x20\x03(\x0b22.matrix_io.malos.v1.comm.ZWaveMsg.ZWaveCommandI\
    nfoR\x07commandB\0:\0\x1a\x87\x01\n\tZWaveNode\x12#\n\x0cservice_name\
    \x18\x01\x20\x01(\tR\x0bserviceNameB\0\x12S\n\x0bzwave_class\x18\x02\x20\
    \x03(\x0b20.matrix_io.malos.v1.comm.ZWaveMsg.ZWaveClassInfoR\nzwaveClass\
    B\0:\0\x1a\xaa\x01\n\x0cZWaveCommand\x12C\n\x07zwclass\x18\x01\x20\x01(\
    \x0e2'.matrix_io.malos.v1.comm.ZWaveClassTypeR\x07zwclassB\0\x129\n\x03c\
    md\x18\x02\x20\x01(\x0e2%.matrix_io.malos.v1.comm.ZWaveCmdTypeR\x03cmdB\
    \0\x12\x18\n\x06params\x18\x03\x20\x01(\x0cR\x06paramsB\0:\0\"_\n\x0fZWa\
    veOperations\x12\t\n\x05UNDEF\x10\0\x12\x08\n\x04SEND\x10\x01\x12\x0b\n\
    \x07ADDNODE\x10\x02\x12\x0e\n\nREMOVENODE\x10\x03\x12\x0e\n\nSETDEFAULT\
    \x10\x04\x12\x08\n\x04LIST\x10\x05\x1a\0:\0\"^\n\nLircParams\x12\x18\n\
    \x06device\x18\x01\x20\x01(\tR\x06deviceB\0\x12\x1a\n\x07command\x18\x02\
    \x20\x01(\tR\x07commandB\0\x12\x18\n\x06config\x18\x03\x20\x01(\tR\x06co\
    nfigB\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
