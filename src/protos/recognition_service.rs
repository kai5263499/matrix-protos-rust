// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `matrix_io/recognition/v1/recognition_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct StoreFeatureDescriptorsRequest {
    // message fields
    pub vision_request: ::protobuf::SingularPtrField<super::vision_service::VisionRequest>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub feature_descriptors: ::protobuf::RepeatedField<super::recognition::FeatureDescriptor>,
    pub device_id: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoreFeatureDescriptorsRequest {
    fn default() -> &'a StoreFeatureDescriptorsRequest {
        <StoreFeatureDescriptorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StoreFeatureDescriptorsRequest {
    pub fn new() -> StoreFeatureDescriptorsRequest {
        ::std::default::Default::default()
    }

    // .matrix_io.vision.v1.VisionRequest vision_request = 1;


    pub fn get_vision_request(&self) -> &super::vision_service::VisionRequest {
        self.vision_request.as_ref().unwrap_or_else(|| <super::vision_service::VisionRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vision_request(&mut self) {
        self.vision_request.clear();
    }

    pub fn has_vision_request(&self) -> bool {
        self.vision_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vision_request(&mut self, v: super::vision_service::VisionRequest) {
        self.vision_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vision_request(&mut self) -> &mut super::vision_service::VisionRequest {
        if self.vision_request.is_none() {
            self.vision_request.set_default();
        }
        self.vision_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_vision_request(&mut self) -> super::vision_service::VisionRequest {
        self.vision_request.take().unwrap_or_else(|| super::vision_service::VisionRequest::new())
    }

    // repeated string tags = 2;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.recognition.v1.FeatureDescriptor feature_descriptors = 3;


    pub fn get_feature_descriptors(&self) -> &[super::recognition::FeatureDescriptor] {
        &self.feature_descriptors
    }
    pub fn clear_feature_descriptors(&mut self) {
        self.feature_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_descriptors(&mut self, v: ::protobuf::RepeatedField<super::recognition::FeatureDescriptor>) {
        self.feature_descriptors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feature_descriptors(&mut self) -> &mut ::protobuf::RepeatedField<super::recognition::FeatureDescriptor> {
        &mut self.feature_descriptors
    }

    // Take field
    pub fn take_feature_descriptors(&mut self) -> ::protobuf::RepeatedField<super::recognition::FeatureDescriptor> {
        ::std::mem::replace(&mut self.feature_descriptors, ::protobuf::RepeatedField::new())
    }

    // repeated string device_id = 4;


    pub fn get_device_id(&self) -> &[::std::string::String] {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_id(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_id, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StoreFeatureDescriptorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vision_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.feature_descriptors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vision_request)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.feature_descriptors)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vision_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.feature_descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.device_id {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vision_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tags {
            os.write_string(2, &v)?;
        };
        for v in &self.feature_descriptors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.device_id {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreFeatureDescriptorsRequest {
        StoreFeatureDescriptorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::vision_service::VisionRequest>>(
                "vision_request",
                |m: &StoreFeatureDescriptorsRequest| { &m.vision_request },
                |m: &mut StoreFeatureDescriptorsRequest| { &mut m.vision_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &StoreFeatureDescriptorsRequest| { &m.tags },
                |m: &mut StoreFeatureDescriptorsRequest| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::recognition::FeatureDescriptor>>(
                "feature_descriptors",
                |m: &StoreFeatureDescriptorsRequest| { &m.feature_descriptors },
                |m: &mut StoreFeatureDescriptorsRequest| { &mut m.feature_descriptors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &StoreFeatureDescriptorsRequest| { &m.device_id },
                |m: &mut StoreFeatureDescriptorsRequest| { &mut m.device_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StoreFeatureDescriptorsRequest>(
                "StoreFeatureDescriptorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StoreFeatureDescriptorsRequest {
        static instance: ::protobuf::rt::LazyV2<StoreFeatureDescriptorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StoreFeatureDescriptorsRequest::new)
    }
}

impl ::protobuf::Clear for StoreFeatureDescriptorsRequest {
    fn clear(&mut self) {
        self.vision_request.clear();
        self.tags.clear();
        self.feature_descriptors.clear();
        self.device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreFeatureDescriptorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreFeatureDescriptorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreFeatureDescriptorsResponse {
    // message fields
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoreFeatureDescriptorsResponse {
    fn default() -> &'a StoreFeatureDescriptorsResponse {
        <StoreFeatureDescriptorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StoreFeatureDescriptorsResponse {
    pub fn new() -> StoreFeatureDescriptorsResponse {
        ::std::default::Default::default()
    }

    // repeated string uuids = 1;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StoreFeatureDescriptorsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uuids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreFeatureDescriptorsResponse {
        StoreFeatureDescriptorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &StoreFeatureDescriptorsResponse| { &m.uuids },
                |m: &mut StoreFeatureDescriptorsResponse| { &mut m.uuids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StoreFeatureDescriptorsResponse>(
                "StoreFeatureDescriptorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StoreFeatureDescriptorsResponse {
        static instance: ::protobuf::rt::LazyV2<StoreFeatureDescriptorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StoreFeatureDescriptorsResponse::new)
    }
}

impl ::protobuf::Clear for StoreFeatureDescriptorsResponse {
    fn clear(&mut self) {
        self.uuids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreFeatureDescriptorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreFeatureDescriptorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatureDescriptorsRequest {
    // message fields
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub device_id: ::std::string::String,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeatureDescriptorsRequest {
    fn default() -> &'a GetFeatureDescriptorsRequest {
        <GetFeatureDescriptorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatureDescriptorsRequest {
    pub fn new() -> GetFeatureDescriptorsRequest {
        ::std::default::Default::default()
    }

    // repeated string uuids = 1;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }

    // repeated string tags = 2;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // string device_id = 3;


    pub fn get_device_id(&self) -> &str {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_id, ::std::string::String::new())
    }

    // string next_page_token = 4;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeatureDescriptorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_id);
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uuids {
            os.write_string(1, &v)?;
        };
        for v in &self.tags {
            os.write_string(2, &v)?;
        };
        if !self.device_id.is_empty() {
            os.write_string(3, &self.device_id)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(4, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatureDescriptorsRequest {
        GetFeatureDescriptorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &GetFeatureDescriptorsRequest| { &m.uuids },
                |m: &mut GetFeatureDescriptorsRequest| { &mut m.uuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &GetFeatureDescriptorsRequest| { &m.tags },
                |m: &mut GetFeatureDescriptorsRequest| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &GetFeatureDescriptorsRequest| { &m.device_id },
                |m: &mut GetFeatureDescriptorsRequest| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &GetFeatureDescriptorsRequest| { &m.next_page_token },
                |m: &mut GetFeatureDescriptorsRequest| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeatureDescriptorsRequest>(
                "GetFeatureDescriptorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeatureDescriptorsRequest {
        static instance: ::protobuf::rt::LazyV2<GetFeatureDescriptorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeatureDescriptorsRequest::new)
    }
}

impl ::protobuf::Clear for GetFeatureDescriptorsRequest {
    fn clear(&mut self) {
        self.uuids.clear();
        self.tags.clear();
        self.device_id.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatureDescriptorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatureDescriptorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatureDescriptorsResponse {
    // message fields
    pub feature_descriptor_list: ::protobuf::SingularPtrField<super::recognition::FeatureDescriptorList>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeatureDescriptorsResponse {
    fn default() -> &'a GetFeatureDescriptorsResponse {
        <GetFeatureDescriptorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatureDescriptorsResponse {
    pub fn new() -> GetFeatureDescriptorsResponse {
        ::std::default::Default::default()
    }

    // .matrix_io.recognition.v1.FeatureDescriptorList feature_descriptor_list = 1;


    pub fn get_feature_descriptor_list(&self) -> &super::recognition::FeatureDescriptorList {
        self.feature_descriptor_list.as_ref().unwrap_or_else(|| <super::recognition::FeatureDescriptorList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feature_descriptor_list(&mut self) {
        self.feature_descriptor_list.clear();
    }

    pub fn has_feature_descriptor_list(&self) -> bool {
        self.feature_descriptor_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feature_descriptor_list(&mut self, v: super::recognition::FeatureDescriptorList) {
        self.feature_descriptor_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_descriptor_list(&mut self) -> &mut super::recognition::FeatureDescriptorList {
        if self.feature_descriptor_list.is_none() {
            self.feature_descriptor_list.set_default();
        }
        self.feature_descriptor_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_feature_descriptor_list(&mut self) -> super::recognition::FeatureDescriptorList {
        self.feature_descriptor_list.take().unwrap_or_else(|| super::recognition::FeatureDescriptorList::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeatureDescriptorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.feature_descriptor_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feature_descriptor_list)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.feature_descriptor_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.feature_descriptor_list.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatureDescriptorsResponse {
        GetFeatureDescriptorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::recognition::FeatureDescriptorList>>(
                "feature_descriptor_list",
                |m: &GetFeatureDescriptorsResponse| { &m.feature_descriptor_list },
                |m: &mut GetFeatureDescriptorsResponse| { &mut m.feature_descriptor_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &GetFeatureDescriptorsResponse| { &m.next_page_token },
                |m: &mut GetFeatureDescriptorsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeatureDescriptorsResponse>(
                "GetFeatureDescriptorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeatureDescriptorsResponse {
        static instance: ::protobuf::rt::LazyV2<GetFeatureDescriptorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeatureDescriptorsResponse::new)
    }
}

impl ::protobuf::Clear for GetFeatureDescriptorsResponse {
    fn clear(&mut self) {
        self.feature_descriptor_list.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatureDescriptorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatureDescriptorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteFeatureDescriptorsRequest {
    // message fields
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteFeatureDescriptorsRequest {
    fn default() -> &'a DeleteFeatureDescriptorsRequest {
        <DeleteFeatureDescriptorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFeatureDescriptorsRequest {
    pub fn new() -> DeleteFeatureDescriptorsRequest {
        ::std::default::Default::default()
    }

    // repeated string uuids = 1;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }

    // repeated string tags = 2;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteFeatureDescriptorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uuids {
            os.write_string(1, &v)?;
        };
        for v in &self.tags {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteFeatureDescriptorsRequest {
        DeleteFeatureDescriptorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &DeleteFeatureDescriptorsRequest| { &m.uuids },
                |m: &mut DeleteFeatureDescriptorsRequest| { &mut m.uuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &DeleteFeatureDescriptorsRequest| { &m.tags },
                |m: &mut DeleteFeatureDescriptorsRequest| { &mut m.tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteFeatureDescriptorsRequest>(
                "DeleteFeatureDescriptorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteFeatureDescriptorsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteFeatureDescriptorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteFeatureDescriptorsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteFeatureDescriptorsRequest {
    fn clear(&mut self) {
        self.uuids.clear();
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteFeatureDescriptorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFeatureDescriptorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteFeatureDescriptorsResponse {
    // message fields
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteFeatureDescriptorsResponse {
    fn default() -> &'a DeleteFeatureDescriptorsResponse {
        <DeleteFeatureDescriptorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFeatureDescriptorsResponse {
    pub fn new() -> DeleteFeatureDescriptorsResponse {
        ::std::default::Default::default()
    }

    // repeated string uuids = 1;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteFeatureDescriptorsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uuids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteFeatureDescriptorsResponse {
        DeleteFeatureDescriptorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &DeleteFeatureDescriptorsResponse| { &m.uuids },
                |m: &mut DeleteFeatureDescriptorsResponse| { &mut m.uuids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteFeatureDescriptorsResponse>(
                "DeleteFeatureDescriptorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteFeatureDescriptorsResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteFeatureDescriptorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteFeatureDescriptorsResponse::new)
    }
}

impl ::protobuf::Clear for DeleteFeatureDescriptorsResponse {
    fn clear(&mut self) {
        self.uuids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteFeatureDescriptorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFeatureDescriptorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognizeRequest {
    // message fields
    pub vision_request: ::protobuf::SingularPtrField<super::vision_service::VisionRequest>,
    pub feature_descriptor_list: ::protobuf::SingularPtrField<super::recognition::FeatureDescriptorList>,
    pub matching_algorithm_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognizeRequest {
    fn default() -> &'a RecognizeRequest {
        <RecognizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecognizeRequest {
    pub fn new() -> RecognizeRequest {
        ::std::default::Default::default()
    }

    // .matrix_io.vision.v1.VisionRequest vision_request = 1;


    pub fn get_vision_request(&self) -> &super::vision_service::VisionRequest {
        self.vision_request.as_ref().unwrap_or_else(|| <super::vision_service::VisionRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vision_request(&mut self) {
        self.vision_request.clear();
    }

    pub fn has_vision_request(&self) -> bool {
        self.vision_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vision_request(&mut self, v: super::vision_service::VisionRequest) {
        self.vision_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vision_request(&mut self) -> &mut super::vision_service::VisionRequest {
        if self.vision_request.is_none() {
            self.vision_request.set_default();
        }
        self.vision_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_vision_request(&mut self) -> super::vision_service::VisionRequest {
        self.vision_request.take().unwrap_or_else(|| super::vision_service::VisionRequest::new())
    }

    // .matrix_io.recognition.v1.FeatureDescriptorList feature_descriptor_list = 2;


    pub fn get_feature_descriptor_list(&self) -> &super::recognition::FeatureDescriptorList {
        self.feature_descriptor_list.as_ref().unwrap_or_else(|| <super::recognition::FeatureDescriptorList as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feature_descriptor_list(&mut self) {
        self.feature_descriptor_list.clear();
    }

    pub fn has_feature_descriptor_list(&self) -> bool {
        self.feature_descriptor_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feature_descriptor_list(&mut self, v: super::recognition::FeatureDescriptorList) {
        self.feature_descriptor_list = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_descriptor_list(&mut self) -> &mut super::recognition::FeatureDescriptorList {
        if self.feature_descriptor_list.is_none() {
            self.feature_descriptor_list.set_default();
        }
        self.feature_descriptor_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_feature_descriptor_list(&mut self) -> super::recognition::FeatureDescriptorList {
        self.feature_descriptor_list.take().unwrap_or_else(|| super::recognition::FeatureDescriptorList::new())
    }

    // string matching_algorithm_version = 3;


    pub fn get_matching_algorithm_version(&self) -> &str {
        &self.matching_algorithm_version
    }
    pub fn clear_matching_algorithm_version(&mut self) {
        self.matching_algorithm_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_matching_algorithm_version(&mut self, v: ::std::string::String) {
        self.matching_algorithm_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matching_algorithm_version(&mut self) -> &mut ::std::string::String {
        &mut self.matching_algorithm_version
    }

    // Take field
    pub fn take_matching_algorithm_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.matching_algorithm_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RecognizeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vision_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.feature_descriptor_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vision_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feature_descriptor_list)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.matching_algorithm_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vision_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.feature_descriptor_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.matching_algorithm_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.matching_algorithm_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vision_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.feature_descriptor_list.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.matching_algorithm_version.is_empty() {
            os.write_string(3, &self.matching_algorithm_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognizeRequest {
        RecognizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::vision_service::VisionRequest>>(
                "vision_request",
                |m: &RecognizeRequest| { &m.vision_request },
                |m: &mut RecognizeRequest| { &mut m.vision_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::recognition::FeatureDescriptorList>>(
                "feature_descriptor_list",
                |m: &RecognizeRequest| { &m.feature_descriptor_list },
                |m: &mut RecognizeRequest| { &mut m.feature_descriptor_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "matching_algorithm_version",
                |m: &RecognizeRequest| { &m.matching_algorithm_version },
                |m: &mut RecognizeRequest| { &mut m.matching_algorithm_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognizeRequest>(
                "RecognizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognizeRequest {
        static instance: ::protobuf::rt::LazyV2<RecognizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognizeRequest::new)
    }
}

impl ::protobuf::Clear for RecognizeRequest {
    fn clear(&mut self) {
        self.vision_request.clear();
        self.feature_descriptor_list.clear();
        self.matching_algorithm_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureDescriptorMatch {
    // message fields
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub score: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureDescriptorMatch {
    fn default() -> &'a FeatureDescriptorMatch {
        <FeatureDescriptorMatch as ::protobuf::Message>::default_instance()
    }
}

impl FeatureDescriptorMatch {
    pub fn new() -> FeatureDescriptorMatch {
        ::std::default::Default::default()
    }

    // repeated string tags = 1;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // float score = 2;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }
}

impl ::protobuf::Message for FeatureDescriptorMatch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.score != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tags {
            os.write_string(1, &v)?;
        };
        if self.score != 0. {
            os.write_float(2, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureDescriptorMatch {
        FeatureDescriptorMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &FeatureDescriptorMatch| { &m.tags },
                |m: &mut FeatureDescriptorMatch| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &FeatureDescriptorMatch| { &m.score },
                |m: &mut FeatureDescriptorMatch| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureDescriptorMatch>(
                "FeatureDescriptorMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureDescriptorMatch {
        static instance: ::protobuf::rt::LazyV2<FeatureDescriptorMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureDescriptorMatch::new)
    }
}

impl ::protobuf::Clear for FeatureDescriptorMatch {
    fn clear(&mut self) {
        self.tags.clear();
        self.score = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureDescriptorMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureDescriptorMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognizeResponse {
    // message fields
    pub matches: ::protobuf::RepeatedField<FeatureDescriptorMatch>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognizeResponse {
    fn default() -> &'a RecognizeResponse {
        <RecognizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecognizeResponse {
    pub fn new() -> RecognizeResponse {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.recognition.v1.FeatureDescriptorMatch matches = 1;


    pub fn get_matches(&self) -> &[FeatureDescriptorMatch] {
        &self.matches
    }
    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<FeatureDescriptorMatch>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<FeatureDescriptorMatch> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<FeatureDescriptorMatch> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RecognizeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognizeResponse {
        RecognizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureDescriptorMatch>>(
                "matches",
                |m: &RecognizeResponse| { &m.matches },
                |m: &mut RecognizeResponse| { &mut m.matches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognizeResponse>(
                "RecognizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognizeResponse {
        static instance: ::protobuf::rt::LazyV2<RecognizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognizeResponse::new)
    }
}

impl ::protobuf::Clear for RecognizeResponse {
    fn clear(&mut self) {
        self.matches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatureDescriptorTagsRequest {
    // message fields
    pub device_id: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeatureDescriptorTagsRequest {
    fn default() -> &'a GetFeatureDescriptorTagsRequest {
        <GetFeatureDescriptorTagsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatureDescriptorTagsRequest {
    pub fn new() -> GetFeatureDescriptorTagsRequest {
        ::std::default::Default::default()
    }

    // repeated string device_id = 1;


    pub fn get_device_id(&self) -> &[::std::string::String] {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_id(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_id, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetFeatureDescriptorTagsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.device_id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.device_id {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatureDescriptorTagsRequest {
        GetFeatureDescriptorTagsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &GetFeatureDescriptorTagsRequest| { &m.device_id },
                |m: &mut GetFeatureDescriptorTagsRequest| { &mut m.device_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeatureDescriptorTagsRequest>(
                "GetFeatureDescriptorTagsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeatureDescriptorTagsRequest {
        static instance: ::protobuf::rt::LazyV2<GetFeatureDescriptorTagsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeatureDescriptorTagsRequest::new)
    }
}

impl ::protobuf::Clear for GetFeatureDescriptorTagsRequest {
    fn clear(&mut self) {
        self.device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatureDescriptorTagsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatureDescriptorTagsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureDescriptorTagsForDevice {
    // message fields
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub device_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureDescriptorTagsForDevice {
    fn default() -> &'a FeatureDescriptorTagsForDevice {
        <FeatureDescriptorTagsForDevice as ::protobuf::Message>::default_instance()
    }
}

impl FeatureDescriptorTagsForDevice {
    pub fn new() -> FeatureDescriptorTagsForDevice {
        ::std::default::Default::default()
    }

    // repeated string tags = 1;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // string device_id = 2;


    pub fn get_device_id(&self) -> &str {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeatureDescriptorTagsForDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tags {
            os.write_string(1, &v)?;
        };
        if !self.device_id.is_empty() {
            os.write_string(2, &self.device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureDescriptorTagsForDevice {
        FeatureDescriptorTagsForDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &FeatureDescriptorTagsForDevice| { &m.tags },
                |m: &mut FeatureDescriptorTagsForDevice| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &FeatureDescriptorTagsForDevice| { &m.device_id },
                |m: &mut FeatureDescriptorTagsForDevice| { &mut m.device_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureDescriptorTagsForDevice>(
                "FeatureDescriptorTagsForDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureDescriptorTagsForDevice {
        static instance: ::protobuf::rt::LazyV2<FeatureDescriptorTagsForDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureDescriptorTagsForDevice::new)
    }
}

impl ::protobuf::Clear for FeatureDescriptorTagsForDevice {
    fn clear(&mut self) {
        self.tags.clear();
        self.device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureDescriptorTagsForDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureDescriptorTagsForDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatureDescriptorTagsResponse {
    // message fields
    pub feature_tags_for_device: ::protobuf::RepeatedField<FeatureDescriptorTagsForDevice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeatureDescriptorTagsResponse {
    fn default() -> &'a GetFeatureDescriptorTagsResponse {
        <GetFeatureDescriptorTagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatureDescriptorTagsResponse {
    pub fn new() -> GetFeatureDescriptorTagsResponse {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.recognition.v1.FeatureDescriptorTagsForDevice feature_tags_for_device = 1;


    pub fn get_feature_tags_for_device(&self) -> &[FeatureDescriptorTagsForDevice] {
        &self.feature_tags_for_device
    }
    pub fn clear_feature_tags_for_device(&mut self) {
        self.feature_tags_for_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_tags_for_device(&mut self, v: ::protobuf::RepeatedField<FeatureDescriptorTagsForDevice>) {
        self.feature_tags_for_device = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feature_tags_for_device(&mut self) -> &mut ::protobuf::RepeatedField<FeatureDescriptorTagsForDevice> {
        &mut self.feature_tags_for_device
    }

    // Take field
    pub fn take_feature_tags_for_device(&mut self) -> ::protobuf::RepeatedField<FeatureDescriptorTagsForDevice> {
        ::std::mem::replace(&mut self.feature_tags_for_device, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetFeatureDescriptorTagsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.feature_tags_for_device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.feature_tags_for_device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.feature_tags_for_device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.feature_tags_for_device {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatureDescriptorTagsResponse {
        GetFeatureDescriptorTagsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureDescriptorTagsForDevice>>(
                "feature_tags_for_device",
                |m: &GetFeatureDescriptorTagsResponse| { &m.feature_tags_for_device },
                |m: &mut GetFeatureDescriptorTagsResponse| { &mut m.feature_tags_for_device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeatureDescriptorTagsResponse>(
                "GetFeatureDescriptorTagsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeatureDescriptorTagsResponse {
        static instance: ::protobuf::rt::LazyV2<GetFeatureDescriptorTagsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeatureDescriptorTagsResponse::new)
    }
}

impl ::protobuf::Clear for GetFeatureDescriptorTagsResponse {
    fn clear(&mut self) {
        self.feature_tags_for_device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatureDescriptorTagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatureDescriptorTagsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n2matrix_io/recognition/v1/recognition_service.proto\x12\x18matrix_io.r\
    ecognition.v1\x1a(matrix_io/vision/v1/vision_service.proto\x1a*matrix_io\
    /recognition/v1/recognition.proto\"\x84\x02\n\x1eStoreFeatureDescriptors\
    Request\x12K\n\x0evision_request\x18\x01\x20\x01(\x0b2\".matrix_io.visio\
    n.v1.VisionRequestR\rvisionRequestB\0\x12\x14\n\x04tags\x18\x02\x20\x03(\
    \tR\x04tagsB\0\x12^\n\x13feature_descriptors\x18\x03\x20\x03(\x0b2+.matr\
    ix_io.recognition.v1.FeatureDescriptorR\x12featureDescriptorsB\0\x12\x1d\
    \n\tdevice_id\x18\x04\x20\x03(\tR\x08deviceIdB\0:\0\";\n\x1fStoreFeature\
    DescriptorsResponse\x12\x16\n\x05uuids\x18\x01\x20\x03(\tR\x05uuidsB\0:\
    \0\"\x97\x01\n\x1cGetFeatureDescriptorsRequest\x12\x16\n\x05uuids\x18\
    \x01\x20\x03(\tR\x05uuidsB\0\x12\x14\n\x04tags\x18\x02\x20\x03(\tR\x04ta\
    gsB\0\x12\x1d\n\tdevice_id\x18\x03\x20\x01(\tR\x08deviceIdB\0\x12(\n\x0f\
    next_page_token\x18\x04\x20\x01(\tR\rnextPageTokenB\0:\0\"\xb6\x01\n\x1d\
    GetFeatureDescriptorsResponse\x12i\n\x17feature_descriptor_list\x18\x01\
    \x20\x01(\x0b2/.matrix_io.recognition.v1.FeatureDescriptorListR\x15featu\
    reDescriptorListB\0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextP\
    ageTokenB\0:\0\"Q\n\x1fDeleteFeatureDescriptorsRequest\x12\x16\n\x05uuid\
    s\x18\x01\x20\x03(\tR\x05uuidsB\0\x12\x14\n\x04tags\x18\x02\x20\x03(\tR\
    \x04tagsB\0:\0\"<\n\x20DeleteFeatureDescriptorsResponse\x12\x16\n\x05uui\
    ds\x18\x01\x20\x03(\tR\x05uuidsB\0:\0\"\x8c\x02\n\x10RecognizeRequest\
    \x12K\n\x0evision_request\x18\x01\x20\x01(\x0b2\".matrix_io.vision.v1.Vi\
    sionRequestR\rvisionRequestB\0\x12i\n\x17feature_descriptor_list\x18\x02\
    \x20\x01(\x0b2/.matrix_io.recognition.v1.FeatureDescriptorListR\x15featu\
    reDescriptorListB\0\x12>\n\x1amatching_algorithm_version\x18\x03\x20\x01\
    (\tR\x18matchingAlgorithmVersionB\0:\0\"H\n\x16FeatureDescriptorMatch\
    \x12\x14\n\x04tags\x18\x01\x20\x03(\tR\x04tagsB\0\x12\x16\n\x05score\x18\
    \x02\x20\x01(\x02R\x05scoreB\0:\0\"c\n\x11RecognizeResponse\x12L\n\x07ma\
    tches\x18\x01\x20\x03(\x0b20.matrix_io.recognition.v1.FeatureDescriptorM\
    atchR\x07matchesB\0:\0\"B\n\x1fGetFeatureDescriptorTagsRequest\x12\x1d\n\
    \tdevice_id\x18\x01\x20\x03(\tR\x08deviceIdB\0:\0\"W\n\x1eFeatureDescrip\
    torTagsForDevice\x12\x14\n\x04tags\x18\x01\x20\x03(\tR\x04tagsB\0\x12\
    \x1d\n\tdevice_id\x18\x02\x20\x01(\tR\x08deviceIdB\0:\0\"\x97\x01\n\x20G\
    etFeatureDescriptorTagsResponse\x12q\n\x17feature_tags_for_device\x18\
    \x01\x20\x03(\x0b28.matrix_io.recognition.v1.FeatureDescriptorTagsForDev\
    iceR\x14featureTagsForDeviceB\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
