// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `matrix_io/vision/v1/vision.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct Point {
    // message fields
    pub x: f32,
    pub y: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }
}

impl ::protobuf::Message for Point {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point {
        Point::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Point| { &m.x },
                |m: &mut Point| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Point| { &m.y },
                |m: &mut Point| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Point>(
                "Point",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Point {
        static instance: ::protobuf::rt::LazyV2<Point> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Point::new)
    }
}

impl ::protobuf::Clear for Point {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Size {
    // message fields
    pub width: i32,
    pub height: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Size {
    fn default() -> &'a Size {
        <Size as ::protobuf::Message>::default_instance()
    }
}

impl Size {
    pub fn new() -> Size {
        ::std::default::Default::default()
    }

    // int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = v;
    }

    // int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }
}

impl ::protobuf::Message for Size {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(1, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Size {
        Size::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &Size| { &m.width },
                |m: &mut Size| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &Size| { &m.height },
                |m: &mut Size| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Size>(
                "Size",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Size {
        static instance: ::protobuf::rt::LazyV2<Size> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Size::new)
    }
}

impl ::protobuf::Clear for Size {
    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Size {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Size {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rectangle {
    // message fields
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rectangle {
    fn default() -> &'a Rectangle {
        <Rectangle as ::protobuf::Message>::default_instance()
    }
}

impl Rectangle {
    pub fn new() -> Rectangle {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float width = 3;


    pub fn get_width(&self) -> f32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0.;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = v;
    }

    // float height = 4;


    pub fn get_height(&self) -> f32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0.;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = v;
    }
}

impl ::protobuf::Message for Rectangle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.width = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.width != 0. {
            my_size += 5;
        }
        if self.height != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.width != 0. {
            os.write_float(3, self.width)?;
        }
        if self.height != 0. {
            os.write_float(4, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rectangle {
        Rectangle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Rectangle| { &m.x },
                |m: &mut Rectangle| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Rectangle| { &m.y },
                |m: &mut Rectangle| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "width",
                |m: &Rectangle| { &m.width },
                |m: &mut Rectangle| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "height",
                |m: &Rectangle| { &m.height },
                |m: &mut Rectangle| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rectangle>(
                "Rectangle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rectangle {
        static instance: ::protobuf::rt::LazyV2<Rectangle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rectangle::new)
    }
}

impl ::protobuf::Clear for Rectangle {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.width = 0.;
        self.height = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rectangle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rectangle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VehicleRecognition {
    // message fields
    pub field_type: ::std::string::String,
    pub brand: ::std::string::String,
    pub model: ::std::string::String,
    pub year: i32,
    pub tag: EnumVehicleRecognitionTag,
    pub confidence: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VehicleRecognition {
    fn default() -> &'a VehicleRecognition {
        <VehicleRecognition as ::protobuf::Message>::default_instance()
    }
}

impl VehicleRecognition {
    pub fn new() -> VehicleRecognition {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string brand = 2;


    pub fn get_brand(&self) -> &str {
        &self.brand
    }
    pub fn clear_brand(&mut self) {
        self.brand.clear();
    }

    // Param is passed by value, moved
    pub fn set_brand(&mut self, v: ::std::string::String) {
        self.brand = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brand(&mut self) -> &mut ::std::string::String {
        &mut self.brand
    }

    // Take field
    pub fn take_brand(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.brand, ::std::string::String::new())
    }

    // string model = 3;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // int32 year = 4;


    pub fn get_year(&self) -> i32 {
        self.year
    }
    pub fn clear_year(&mut self) {
        self.year = 0;
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = v;
    }

    // .matrix_io.vision.v1.EnumVehicleRecognitionTag tag = 5;


    pub fn get_tag(&self) -> EnumVehicleRecognitionTag {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: EnumVehicleRecognitionTag) {
        self.tag = v;
    }

    // float confidence = 6;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }
}

impl ::protobuf::Message for VehicleRecognition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.brand)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.year = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if !self.brand.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.brand);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model);
        }
        if self.year != 0 {
            my_size += ::protobuf::rt::value_size(4, self.year, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag != EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(5, self.tag);
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if !self.brand.is_empty() {
            os.write_string(2, &self.brand)?;
        }
        if !self.model.is_empty() {
            os.write_string(3, &self.model)?;
        }
        if self.year != 0 {
            os.write_int32(4, self.year)?;
        }
        if self.tag != EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.tag))?;
        }
        if self.confidence != 0. {
            os.write_float(6, self.confidence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VehicleRecognition {
        VehicleRecognition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &VehicleRecognition| { &m.field_type },
                |m: &mut VehicleRecognition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "brand",
                |m: &VehicleRecognition| { &m.brand },
                |m: &mut VehicleRecognition| { &mut m.brand },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &VehicleRecognition| { &m.model },
                |m: &mut VehicleRecognition| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "year",
                |m: &VehicleRecognition| { &m.year },
                |m: &mut VehicleRecognition| { &mut m.year },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnumVehicleRecognitionTag>>(
                "tag",
                |m: &VehicleRecognition| { &m.tag },
                |m: &mut VehicleRecognition| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "confidence",
                |m: &VehicleRecognition| { &m.confidence },
                |m: &mut VehicleRecognition| { &mut m.confidence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VehicleRecognition>(
                "VehicleRecognition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VehicleRecognition {
        static instance: ::protobuf::rt::LazyV2<VehicleRecognition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VehicleRecognition::new)
    }
}

impl ::protobuf::Clear for VehicleRecognition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.brand.clear();
        self.model.clear();
        self.year = 0;
        self.tag = EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED;
        self.confidence = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VehicleRecognition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehicleRecognition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FacialRecognition {
    // message fields
    pub tag: EnumFacialRecognitionTag,
    pub confidence: f32,
    pub age: i32,
    pub age_class: FacialRecognition_AgeClass,
    pub gender: FacialRecognition_Gender,
    pub emotion: FacialRecognition_Emotion,
    pub face_descriptor: ::std::vec::Vec<f32>,
    pub face_id: ::std::string::String,
    pub pose_yaw: f32,
    pub pose_roll: f32,
    pub pose_pitch: f32,
    pub is_looking: bool,
    pub basic_feature: ::protobuf::SingularPtrField<FacialRecognition_BasicFaceFeature>,
    pub is_face: bool,
    pub have_glass: bool,
    pub beard: bool,
    pub glasses: FacialRecognition_Glasses,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FacialRecognition {
    fn default() -> &'a FacialRecognition {
        <FacialRecognition as ::protobuf::Message>::default_instance()
    }
}

impl FacialRecognition {
    pub fn new() -> FacialRecognition {
        ::std::default::Default::default()
    }

    // .matrix_io.vision.v1.EnumFacialRecognitionTag tag = 1;


    pub fn get_tag(&self) -> EnumFacialRecognitionTag {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: EnumFacialRecognitionTag) {
        self.tag = v;
    }

    // float confidence = 2;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }

    // int32 age = 3;


    pub fn get_age(&self) -> i32 {
        self.age
    }
    pub fn clear_age(&mut self) {
        self.age = 0;
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: i32) {
        self.age = v;
    }

    // .matrix_io.vision.v1.FacialRecognition.AgeClass age_class = 13;


    pub fn get_age_class(&self) -> FacialRecognition_AgeClass {
        self.age_class
    }
    pub fn clear_age_class(&mut self) {
        self.age_class = FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_age_class(&mut self, v: FacialRecognition_AgeClass) {
        self.age_class = v;
    }

    // .matrix_io.vision.v1.FacialRecognition.Gender gender = 4;


    pub fn get_gender(&self) -> FacialRecognition_Gender {
        self.gender
    }
    pub fn clear_gender(&mut self) {
        self.gender = FacialRecognition_Gender::GENDER_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: FacialRecognition_Gender) {
        self.gender = v;
    }

    // .matrix_io.vision.v1.FacialRecognition.Emotion emotion = 5;


    pub fn get_emotion(&self) -> FacialRecognition_Emotion {
        self.emotion
    }
    pub fn clear_emotion(&mut self) {
        self.emotion = FacialRecognition_Emotion::EMOTION_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_emotion(&mut self, v: FacialRecognition_Emotion) {
        self.emotion = v;
    }

    // repeated float face_descriptor = 6;


    pub fn get_face_descriptor(&self) -> &[f32] {
        &self.face_descriptor
    }
    pub fn clear_face_descriptor(&mut self) {
        self.face_descriptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_face_descriptor(&mut self, v: ::std::vec::Vec<f32>) {
        self.face_descriptor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_face_descriptor(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.face_descriptor
    }

    // Take field
    pub fn take_face_descriptor(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.face_descriptor, ::std::vec::Vec::new())
    }

    // string face_id = 7;


    pub fn get_face_id(&self) -> &str {
        &self.face_id
    }
    pub fn clear_face_id(&mut self) {
        self.face_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_face_id(&mut self, v: ::std::string::String) {
        self.face_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_face_id(&mut self) -> &mut ::std::string::String {
        &mut self.face_id
    }

    // Take field
    pub fn take_face_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.face_id, ::std::string::String::new())
    }

    // float pose_yaw = 8;


    pub fn get_pose_yaw(&self) -> f32 {
        self.pose_yaw
    }
    pub fn clear_pose_yaw(&mut self) {
        self.pose_yaw = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pose_yaw(&mut self, v: f32) {
        self.pose_yaw = v;
    }

    // float pose_roll = 9;


    pub fn get_pose_roll(&self) -> f32 {
        self.pose_roll
    }
    pub fn clear_pose_roll(&mut self) {
        self.pose_roll = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pose_roll(&mut self, v: f32) {
        self.pose_roll = v;
    }

    // float pose_pitch = 10;


    pub fn get_pose_pitch(&self) -> f32 {
        self.pose_pitch
    }
    pub fn clear_pose_pitch(&mut self) {
        self.pose_pitch = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pose_pitch(&mut self, v: f32) {
        self.pose_pitch = v;
    }

    // bool is_looking = 14;


    pub fn get_is_looking(&self) -> bool {
        self.is_looking
    }
    pub fn clear_is_looking(&mut self) {
        self.is_looking = false;
    }

    // Param is passed by value, moved
    pub fn set_is_looking(&mut self, v: bool) {
        self.is_looking = v;
    }

    // .matrix_io.vision.v1.FacialRecognition.BasicFaceFeature basic_feature = 11;


    pub fn get_basic_feature(&self) -> &FacialRecognition_BasicFaceFeature {
        self.basic_feature.as_ref().unwrap_or_else(|| <FacialRecognition_BasicFaceFeature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_basic_feature(&mut self) {
        self.basic_feature.clear();
    }

    pub fn has_basic_feature(&self) -> bool {
        self.basic_feature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_basic_feature(&mut self, v: FacialRecognition_BasicFaceFeature) {
        self.basic_feature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_basic_feature(&mut self) -> &mut FacialRecognition_BasicFaceFeature {
        if self.basic_feature.is_none() {
            self.basic_feature.set_default();
        }
        self.basic_feature.as_mut().unwrap()
    }

    // Take field
    pub fn take_basic_feature(&mut self) -> FacialRecognition_BasicFaceFeature {
        self.basic_feature.take().unwrap_or_else(|| FacialRecognition_BasicFaceFeature::new())
    }

    // bool is_face = 12;


    pub fn get_is_face(&self) -> bool {
        self.is_face
    }
    pub fn clear_is_face(&mut self) {
        self.is_face = false;
    }

    // Param is passed by value, moved
    pub fn set_is_face(&mut self, v: bool) {
        self.is_face = v;
    }

    // bool have_glass = 15;


    pub fn get_have_glass(&self) -> bool {
        self.have_glass
    }
    pub fn clear_have_glass(&mut self) {
        self.have_glass = false;
    }

    // Param is passed by value, moved
    pub fn set_have_glass(&mut self, v: bool) {
        self.have_glass = v;
    }

    // bool beard = 16;


    pub fn get_beard(&self) -> bool {
        self.beard
    }
    pub fn clear_beard(&mut self) {
        self.beard = false;
    }

    // Param is passed by value, moved
    pub fn set_beard(&mut self, v: bool) {
        self.beard = v;
    }

    // .matrix_io.vision.v1.FacialRecognition.Glasses glasses = 17;


    pub fn get_glasses(&self) -> FacialRecognition_Glasses {
        self.glasses
    }
    pub fn clear_glasses(&mut self) {
        self.glasses = FacialRecognition_Glasses::GLASSES_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_glasses(&mut self, v: FacialRecognition_Glasses) {
        self.glasses = v;
    }
}

impl ::protobuf::Message for FacialRecognition {
    fn is_initialized(&self) -> bool {
        for v in &self.basic_feature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.age = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.age_class, 13, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.gender, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.emotion, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.face_descriptor)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.face_id)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pose_yaw = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pose_roll = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pose_pitch = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_looking = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.basic_feature)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_face = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.have_glass = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.beard = tmp;
                },
                17 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.glasses, 17, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.tag);
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        if self.age != 0 {
            my_size += ::protobuf::rt::value_size(3, self.age, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.age_class != FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(13, self.age_class);
        }
        if self.gender != FacialRecognition_Gender::GENDER_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(4, self.gender);
        }
        if self.emotion != FacialRecognition_Emotion::EMOTION_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(5, self.emotion);
        }
        if !self.face_descriptor.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.face_descriptor.len() * 4) as u32) + (self.face_descriptor.len() * 4) as u32;
        }
        if !self.face_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.face_id);
        }
        if self.pose_yaw != 0. {
            my_size += 5;
        }
        if self.pose_roll != 0. {
            my_size += 5;
        }
        if self.pose_pitch != 0. {
            my_size += 5;
        }
        if self.is_looking != false {
            my_size += 2;
        }
        if let Some(ref v) = self.basic_feature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_face != false {
            my_size += 2;
        }
        if self.have_glass != false {
            my_size += 2;
        }
        if self.beard != false {
            my_size += 3;
        }
        if self.glasses != FacialRecognition_Glasses::GLASSES_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(17, self.glasses);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag != EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.tag))?;
        }
        if self.confidence != 0. {
            os.write_float(2, self.confidence)?;
        }
        if self.age != 0 {
            os.write_int32(3, self.age)?;
        }
        if self.age_class != FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.age_class))?;
        }
        if self.gender != FacialRecognition_Gender::GENDER_NOT_DEFINED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.gender))?;
        }
        if self.emotion != FacialRecognition_Emotion::EMOTION_NOT_DEFINED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.emotion))?;
        }
        if !self.face_descriptor.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.face_descriptor.len() * 4) as u32)?;
            for v in &self.face_descriptor {
                os.write_float_no_tag(*v)?;
            };
        }
        if !self.face_id.is_empty() {
            os.write_string(7, &self.face_id)?;
        }
        if self.pose_yaw != 0. {
            os.write_float(8, self.pose_yaw)?;
        }
        if self.pose_roll != 0. {
            os.write_float(9, self.pose_roll)?;
        }
        if self.pose_pitch != 0. {
            os.write_float(10, self.pose_pitch)?;
        }
        if self.is_looking != false {
            os.write_bool(14, self.is_looking)?;
        }
        if let Some(ref v) = self.basic_feature.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_face != false {
            os.write_bool(12, self.is_face)?;
        }
        if self.have_glass != false {
            os.write_bool(15, self.have_glass)?;
        }
        if self.beard != false {
            os.write_bool(16, self.beard)?;
        }
        if self.glasses != FacialRecognition_Glasses::GLASSES_NOT_DEFINED {
            os.write_enum(17, ::protobuf::ProtobufEnum::value(&self.glasses))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FacialRecognition {
        FacialRecognition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnumFacialRecognitionTag>>(
                "tag",
                |m: &FacialRecognition| { &m.tag },
                |m: &mut FacialRecognition| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "confidence",
                |m: &FacialRecognition| { &m.confidence },
                |m: &mut FacialRecognition| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "age",
                |m: &FacialRecognition| { &m.age },
                |m: &mut FacialRecognition| { &mut m.age },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FacialRecognition_AgeClass>>(
                "age_class",
                |m: &FacialRecognition| { &m.age_class },
                |m: &mut FacialRecognition| { &mut m.age_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FacialRecognition_Gender>>(
                "gender",
                |m: &FacialRecognition| { &m.gender },
                |m: &mut FacialRecognition| { &mut m.gender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FacialRecognition_Emotion>>(
                "emotion",
                |m: &FacialRecognition| { &m.emotion },
                |m: &mut FacialRecognition| { &mut m.emotion },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "face_descriptor",
                |m: &FacialRecognition| { &m.face_descriptor },
                |m: &mut FacialRecognition| { &mut m.face_descriptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "face_id",
                |m: &FacialRecognition| { &m.face_id },
                |m: &mut FacialRecognition| { &mut m.face_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pose_yaw",
                |m: &FacialRecognition| { &m.pose_yaw },
                |m: &mut FacialRecognition| { &mut m.pose_yaw },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pose_roll",
                |m: &FacialRecognition| { &m.pose_roll },
                |m: &mut FacialRecognition| { &mut m.pose_roll },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pose_pitch",
                |m: &FacialRecognition| { &m.pose_pitch },
                |m: &mut FacialRecognition| { &mut m.pose_pitch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_looking",
                |m: &FacialRecognition| { &m.is_looking },
                |m: &mut FacialRecognition| { &mut m.is_looking },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FacialRecognition_BasicFaceFeature>>(
                "basic_feature",
                |m: &FacialRecognition| { &m.basic_feature },
                |m: &mut FacialRecognition| { &mut m.basic_feature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_face",
                |m: &FacialRecognition| { &m.is_face },
                |m: &mut FacialRecognition| { &mut m.is_face },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "have_glass",
                |m: &FacialRecognition| { &m.have_glass },
                |m: &mut FacialRecognition| { &mut m.have_glass },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "beard",
                |m: &FacialRecognition| { &m.beard },
                |m: &mut FacialRecognition| { &mut m.beard },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FacialRecognition_Glasses>>(
                "glasses",
                |m: &FacialRecognition| { &m.glasses },
                |m: &mut FacialRecognition| { &mut m.glasses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FacialRecognition>(
                "FacialRecognition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FacialRecognition {
        static instance: ::protobuf::rt::LazyV2<FacialRecognition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FacialRecognition::new)
    }
}

impl ::protobuf::Clear for FacialRecognition {
    fn clear(&mut self) {
        self.tag = EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED;
        self.confidence = 0.;
        self.age = 0;
        self.age_class = FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED;
        self.gender = FacialRecognition_Gender::GENDER_NOT_DEFINED;
        self.emotion = FacialRecognition_Emotion::EMOTION_NOT_DEFINED;
        self.face_descriptor.clear();
        self.face_id.clear();
        self.pose_yaw = 0.;
        self.pose_roll = 0.;
        self.pose_pitch = 0.;
        self.is_looking = false;
        self.basic_feature.clear();
        self.is_face = false;
        self.have_glass = false;
        self.beard = false;
        self.glasses = FacialRecognition_Glasses::GLASSES_NOT_DEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FacialRecognition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FacialRecognition_BasicFaceFeature {
    // message fields
    pub mouth: ::protobuf::RepeatedField<Point>,
    pub left_eye: ::protobuf::RepeatedField<Point>,
    pub right_eye: ::protobuf::RepeatedField<Point>,
    pub nose: ::protobuf::RepeatedField<Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FacialRecognition_BasicFaceFeature {
    fn default() -> &'a FacialRecognition_BasicFaceFeature {
        <FacialRecognition_BasicFaceFeature as ::protobuf::Message>::default_instance()
    }
}

impl FacialRecognition_BasicFaceFeature {
    pub fn new() -> FacialRecognition_BasicFaceFeature {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.vision.v1.Point mouth = 1;


    pub fn get_mouth(&self) -> &[Point] {
        &self.mouth
    }
    pub fn clear_mouth(&mut self) {
        self.mouth.clear();
    }

    // Param is passed by value, moved
    pub fn set_mouth(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.mouth = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mouth(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.mouth
    }

    // Take field
    pub fn take_mouth(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.mouth, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.Point left_eye = 2;


    pub fn get_left_eye(&self) -> &[Point] {
        &self.left_eye
    }
    pub fn clear_left_eye(&mut self) {
        self.left_eye.clear();
    }

    // Param is passed by value, moved
    pub fn set_left_eye(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.left_eye = v;
    }

    // Mutable pointer to the field.
    pub fn mut_left_eye(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.left_eye
    }

    // Take field
    pub fn take_left_eye(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.left_eye, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.Point right_eye = 3;


    pub fn get_right_eye(&self) -> &[Point] {
        &self.right_eye
    }
    pub fn clear_right_eye(&mut self) {
        self.right_eye.clear();
    }

    // Param is passed by value, moved
    pub fn set_right_eye(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.right_eye = v;
    }

    // Mutable pointer to the field.
    pub fn mut_right_eye(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.right_eye
    }

    // Take field
    pub fn take_right_eye(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.right_eye, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.Point nose = 4;


    pub fn get_nose(&self) -> &[Point] {
        &self.nose
    }
    pub fn clear_nose(&mut self) {
        self.nose.clear();
    }

    // Param is passed by value, moved
    pub fn set_nose(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.nose = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nose(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.nose
    }

    // Take field
    pub fn take_nose(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.nose, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FacialRecognition_BasicFaceFeature {
    fn is_initialized(&self) -> bool {
        for v in &self.mouth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left_eye {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right_eye {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nose {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mouth)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.left_eye)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.right_eye)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nose)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mouth {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.left_eye {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.right_eye {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.nose {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mouth {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.left_eye {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.right_eye {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.nose {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FacialRecognition_BasicFaceFeature {
        FacialRecognition_BasicFaceFeature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "mouth",
                |m: &FacialRecognition_BasicFaceFeature| { &m.mouth },
                |m: &mut FacialRecognition_BasicFaceFeature| { &mut m.mouth },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "left_eye",
                |m: &FacialRecognition_BasicFaceFeature| { &m.left_eye },
                |m: &mut FacialRecognition_BasicFaceFeature| { &mut m.left_eye },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "right_eye",
                |m: &FacialRecognition_BasicFaceFeature| { &m.right_eye },
                |m: &mut FacialRecognition_BasicFaceFeature| { &mut m.right_eye },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "nose",
                |m: &FacialRecognition_BasicFaceFeature| { &m.nose },
                |m: &mut FacialRecognition_BasicFaceFeature| { &mut m.nose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FacialRecognition_BasicFaceFeature>(
                "FacialRecognition.BasicFaceFeature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FacialRecognition_BasicFaceFeature {
        static instance: ::protobuf::rt::LazyV2<FacialRecognition_BasicFaceFeature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FacialRecognition_BasicFaceFeature::new)
    }
}

impl ::protobuf::Clear for FacialRecognition_BasicFaceFeature {
    fn clear(&mut self) {
        self.mouth.clear();
        self.left_eye.clear();
        self.right_eye.clear();
        self.nose.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FacialRecognition_BasicFaceFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition_BasicFaceFeature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FacialRecognition_AgeClass {
    AGE_CLASS_NOT_DEFINED = 0,
    CHILDREN = 1,
    YOUNG_ADULT = 2,
    ADULT = 3,
    SENIOR = 4,
}

impl ::protobuf::ProtobufEnum for FacialRecognition_AgeClass {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FacialRecognition_AgeClass> {
        match value {
            0 => ::std::option::Option::Some(FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED),
            1 => ::std::option::Option::Some(FacialRecognition_AgeClass::CHILDREN),
            2 => ::std::option::Option::Some(FacialRecognition_AgeClass::YOUNG_ADULT),
            3 => ::std::option::Option::Some(FacialRecognition_AgeClass::ADULT),
            4 => ::std::option::Option::Some(FacialRecognition_AgeClass::SENIOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FacialRecognition_AgeClass] = &[
            FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED,
            FacialRecognition_AgeClass::CHILDREN,
            FacialRecognition_AgeClass::YOUNG_ADULT,
            FacialRecognition_AgeClass::ADULT,
            FacialRecognition_AgeClass::SENIOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FacialRecognition_AgeClass>("FacialRecognition.AgeClass", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FacialRecognition_AgeClass {
}

impl ::std::default::Default for FacialRecognition_AgeClass {
    fn default() -> Self {
        FacialRecognition_AgeClass::AGE_CLASS_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition_AgeClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FacialRecognition_Gender {
    GENDER_NOT_DEFINED = 0,
    MALE = 1,
    FEMALE = 2,
}

impl ::protobuf::ProtobufEnum for FacialRecognition_Gender {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FacialRecognition_Gender> {
        match value {
            0 => ::std::option::Option::Some(FacialRecognition_Gender::GENDER_NOT_DEFINED),
            1 => ::std::option::Option::Some(FacialRecognition_Gender::MALE),
            2 => ::std::option::Option::Some(FacialRecognition_Gender::FEMALE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FacialRecognition_Gender] = &[
            FacialRecognition_Gender::GENDER_NOT_DEFINED,
            FacialRecognition_Gender::MALE,
            FacialRecognition_Gender::FEMALE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FacialRecognition_Gender>("FacialRecognition.Gender", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FacialRecognition_Gender {
}

impl ::std::default::Default for FacialRecognition_Gender {
    fn default() -> Self {
        FacialRecognition_Gender::GENDER_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition_Gender {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FacialRecognition_Emotion {
    EMOTION_NOT_DEFINED = 0,
    ANGRY = 1,
    DISGUST = 2,
    CONFUSED = 3,
    HAPPY = 4,
    SAD = 5,
    SURPRISED = 6,
    CALM = 7,
    FEAR = 8,
    NEUTRAL = 9,
}

impl ::protobuf::ProtobufEnum for FacialRecognition_Emotion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FacialRecognition_Emotion> {
        match value {
            0 => ::std::option::Option::Some(FacialRecognition_Emotion::EMOTION_NOT_DEFINED),
            1 => ::std::option::Option::Some(FacialRecognition_Emotion::ANGRY),
            2 => ::std::option::Option::Some(FacialRecognition_Emotion::DISGUST),
            3 => ::std::option::Option::Some(FacialRecognition_Emotion::CONFUSED),
            4 => ::std::option::Option::Some(FacialRecognition_Emotion::HAPPY),
            5 => ::std::option::Option::Some(FacialRecognition_Emotion::SAD),
            6 => ::std::option::Option::Some(FacialRecognition_Emotion::SURPRISED),
            7 => ::std::option::Option::Some(FacialRecognition_Emotion::CALM),
            8 => ::std::option::Option::Some(FacialRecognition_Emotion::FEAR),
            9 => ::std::option::Option::Some(FacialRecognition_Emotion::NEUTRAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FacialRecognition_Emotion] = &[
            FacialRecognition_Emotion::EMOTION_NOT_DEFINED,
            FacialRecognition_Emotion::ANGRY,
            FacialRecognition_Emotion::DISGUST,
            FacialRecognition_Emotion::CONFUSED,
            FacialRecognition_Emotion::HAPPY,
            FacialRecognition_Emotion::SAD,
            FacialRecognition_Emotion::SURPRISED,
            FacialRecognition_Emotion::CALM,
            FacialRecognition_Emotion::FEAR,
            FacialRecognition_Emotion::NEUTRAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FacialRecognition_Emotion>("FacialRecognition.Emotion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FacialRecognition_Emotion {
}

impl ::std::default::Default for FacialRecognition_Emotion {
    fn default() -> Self {
        FacialRecognition_Emotion::EMOTION_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition_Emotion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FacialRecognition_Glasses {
    GLASSES_NOT_DEFINED = 0,
    GLASSES = 1,
    NO_GLASSES = 2,
    SUN_GLASSES = 3,
}

impl ::protobuf::ProtobufEnum for FacialRecognition_Glasses {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FacialRecognition_Glasses> {
        match value {
            0 => ::std::option::Option::Some(FacialRecognition_Glasses::GLASSES_NOT_DEFINED),
            1 => ::std::option::Option::Some(FacialRecognition_Glasses::GLASSES),
            2 => ::std::option::Option::Some(FacialRecognition_Glasses::NO_GLASSES),
            3 => ::std::option::Option::Some(FacialRecognition_Glasses::SUN_GLASSES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FacialRecognition_Glasses] = &[
            FacialRecognition_Glasses::GLASSES_NOT_DEFINED,
            FacialRecognition_Glasses::GLASSES,
            FacialRecognition_Glasses::NO_GLASSES,
            FacialRecognition_Glasses::SUN_GLASSES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FacialRecognition_Glasses>("FacialRecognition.Glasses", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FacialRecognition_Glasses {
}

impl ::std::default::Default for FacialRecognition_Glasses {
    fn default() -> Self {
        FacialRecognition_Glasses::GLASSES_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for FacialRecognition_Glasses {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZoneConfig {
    // message fields
    pub name: ::std::string::String,
    pub point_a: ::protobuf::SingularPtrField<Point>,
    pub point_b: ::protobuf::SingularPtrField<Point>,
    pub height: i32,
    pub real_height: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZoneConfig {
    fn default() -> &'a ZoneConfig {
        <ZoneConfig as ::protobuf::Message>::default_instance()
    }
}

impl ZoneConfig {
    pub fn new() -> ZoneConfig {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .matrix_io.vision.v1.Point point_a = 2;


    pub fn get_point_a(&self) -> &Point {
        self.point_a.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_point_a(&mut self) {
        self.point_a.clear();
    }

    pub fn has_point_a(&self) -> bool {
        self.point_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_a(&mut self, v: Point) {
        self.point_a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point_a(&mut self) -> &mut Point {
        if self.point_a.is_none() {
            self.point_a.set_default();
        }
        self.point_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_point_a(&mut self) -> Point {
        self.point_a.take().unwrap_or_else(|| Point::new())
    }

    // .matrix_io.vision.v1.Point point_b = 3;


    pub fn get_point_b(&self) -> &Point {
        self.point_b.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_point_b(&mut self) {
        self.point_b.clear();
    }

    pub fn has_point_b(&self) -> bool {
        self.point_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_b(&mut self, v: Point) {
        self.point_b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point_b(&mut self) -> &mut Point {
        if self.point_b.is_none() {
            self.point_b.set_default();
        }
        self.point_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_point_b(&mut self) -> Point {
        self.point_b.take().unwrap_or_else(|| Point::new())
    }

    // int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // float real_height = 5;


    pub fn get_real_height(&self) -> f32 {
        self.real_height
    }
    pub fn clear_real_height(&mut self) {
        self.real_height = 0.;
    }

    // Param is passed by value, moved
    pub fn set_real_height(&mut self, v: f32) {
        self.real_height = v;
    }
}

impl ::protobuf::Message for ZoneConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.point_a {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.point_b {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point_a)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point_b)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.real_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.point_a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.point_b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.real_height != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.point_a.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.point_b.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        if self.real_height != 0. {
            os.write_float(5, self.real_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZoneConfig {
        ZoneConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ZoneConfig| { &m.name },
                |m: &mut ZoneConfig| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "point_a",
                |m: &ZoneConfig| { &m.point_a },
                |m: &mut ZoneConfig| { &mut m.point_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "point_b",
                |m: &ZoneConfig| { &m.point_b },
                |m: &mut ZoneConfig| { &mut m.point_b },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &ZoneConfig| { &m.height },
                |m: &mut ZoneConfig| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "real_height",
                |m: &ZoneConfig| { &m.real_height },
                |m: &mut ZoneConfig| { &mut m.real_height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZoneConfig>(
                "ZoneConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZoneConfig {
        static instance: ::protobuf::rt::LazyV2<ZoneConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZoneConfig::new)
    }
}

impl ::protobuf::Clear for ZoneConfig {
    fn clear(&mut self) {
        self.name.clear();
        self.point_a.clear();
        self.point_b.clear();
        self.height = 0;
        self.real_height = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZoneConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZoneConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AreaConfig {
    // message fields
    pub name: ::std::string::String,
    pub point: ::protobuf::RepeatedField<Point>,
    pub count_direction: ::protobuf::SingularPtrField<Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AreaConfig {
    fn default() -> &'a AreaConfig {
        <AreaConfig as ::protobuf::Message>::default_instance()
    }
}

impl AreaConfig {
    pub fn new() -> AreaConfig {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .matrix_io.vision.v1.Point point = 2;


    pub fn get_point(&self) -> &[Point] {
        &self.point
    }
    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.point = v;
    }

    // Mutable pointer to the field.
    pub fn mut_point(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.point
    }

    // Take field
    pub fn take_point(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.point, ::protobuf::RepeatedField::new())
    }

    // .matrix_io.vision.v1.Point count_direction = 3;


    pub fn get_count_direction(&self) -> &Point {
        self.count_direction.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_count_direction(&mut self) {
        self.count_direction.clear();
    }

    pub fn has_count_direction(&self) -> bool {
        self.count_direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_direction(&mut self, v: Point) {
        self.count_direction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_count_direction(&mut self) -> &mut Point {
        if self.count_direction.is_none() {
            self.count_direction.set_default();
        }
        self.count_direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_count_direction(&mut self) -> Point {
        self.count_direction.take().unwrap_or_else(|| Point::new())
    }
}

impl ::protobuf::Message for AreaConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.count_direction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.point)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.count_direction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.point {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.count_direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.point {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.count_direction.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AreaConfig {
        AreaConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AreaConfig| { &m.name },
                |m: &mut AreaConfig| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "point",
                |m: &AreaConfig| { &m.point },
                |m: &mut AreaConfig| { &mut m.point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "count_direction",
                |m: &AreaConfig| { &m.count_direction },
                |m: &mut AreaConfig| { &mut m.count_direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AreaConfig>(
                "AreaConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AreaConfig {
        static instance: ::protobuf::rt::LazyV2<AreaConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AreaConfig::new)
    }
}

impl ::protobuf::Clear for AreaConfig {
    fn clear(&mut self) {
        self.name.clear();
        self.point.clear();
        self.count_direction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AreaConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AreaConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AreaAndZoneConfig {
    // message fields
    pub area: ::protobuf::RepeatedField<AreaConfig>,
    pub zone: ::protobuf::RepeatedField<ZoneConfig>,
    pub region_of_interest: ::protobuf::RepeatedField<Rectangle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AreaAndZoneConfig {
    fn default() -> &'a AreaAndZoneConfig {
        <AreaAndZoneConfig as ::protobuf::Message>::default_instance()
    }
}

impl AreaAndZoneConfig {
    pub fn new() -> AreaAndZoneConfig {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.vision.v1.AreaConfig area = 1;


    pub fn get_area(&self) -> &[AreaConfig] {
        &self.area
    }
    pub fn clear_area(&mut self) {
        self.area.clear();
    }

    // Param is passed by value, moved
    pub fn set_area(&mut self, v: ::protobuf::RepeatedField<AreaConfig>) {
        self.area = v;
    }

    // Mutable pointer to the field.
    pub fn mut_area(&mut self) -> &mut ::protobuf::RepeatedField<AreaConfig> {
        &mut self.area
    }

    // Take field
    pub fn take_area(&mut self) -> ::protobuf::RepeatedField<AreaConfig> {
        ::std::mem::replace(&mut self.area, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.ZoneConfig zone = 2;


    pub fn get_zone(&self) -> &[ZoneConfig] {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::protobuf::RepeatedField<ZoneConfig>) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zone(&mut self) -> &mut ::protobuf::RepeatedField<ZoneConfig> {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::protobuf::RepeatedField<ZoneConfig> {
        ::std::mem::replace(&mut self.zone, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.Rectangle region_of_interest = 3;


    pub fn get_region_of_interest(&self) -> &[Rectangle] {
        &self.region_of_interest
    }
    pub fn clear_region_of_interest(&mut self) {
        self.region_of_interest.clear();
    }

    // Param is passed by value, moved
    pub fn set_region_of_interest(&mut self, v: ::protobuf::RepeatedField<Rectangle>) {
        self.region_of_interest = v;
    }

    // Mutable pointer to the field.
    pub fn mut_region_of_interest(&mut self) -> &mut ::protobuf::RepeatedField<Rectangle> {
        &mut self.region_of_interest
    }

    // Take field
    pub fn take_region_of_interest(&mut self) -> ::protobuf::RepeatedField<Rectangle> {
        ::std::mem::replace(&mut self.region_of_interest, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AreaAndZoneConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.area {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zone {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_of_interest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.area)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.region_of_interest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.area {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.zone {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.region_of_interest {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.area {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.zone {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.region_of_interest {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AreaAndZoneConfig {
        AreaAndZoneConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AreaConfig>>(
                "area",
                |m: &AreaAndZoneConfig| { &m.area },
                |m: &mut AreaAndZoneConfig| { &mut m.area },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZoneConfig>>(
                "zone",
                |m: &AreaAndZoneConfig| { &m.zone },
                |m: &mut AreaAndZoneConfig| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rectangle>>(
                "region_of_interest",
                |m: &AreaAndZoneConfig| { &m.region_of_interest },
                |m: &mut AreaAndZoneConfig| { &mut m.region_of_interest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AreaAndZoneConfig>(
                "AreaAndZoneConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AreaAndZoneConfig {
        static instance: ::protobuf::rt::LazyV2<AreaAndZoneConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AreaAndZoneConfig::new)
    }
}

impl ::protobuf::Clear for AreaAndZoneConfig {
    fn clear(&mut self) {
        self.area.clear();
        self.zone.clear();
        self.region_of_interest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AreaAndZoneConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AreaAndZoneConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VehicleConfig {
    // message fields
    pub camera_url: ::std::string::String,
    pub area_and_zone: ::protobuf::SingularPtrField<AreaAndZoneConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VehicleConfig {
    fn default() -> &'a VehicleConfig {
        <VehicleConfig as ::protobuf::Message>::default_instance()
    }
}

impl VehicleConfig {
    pub fn new() -> VehicleConfig {
        ::std::default::Default::default()
    }

    // string camera_url = 1;


    pub fn get_camera_url(&self) -> &str {
        &self.camera_url
    }
    pub fn clear_camera_url(&mut self) {
        self.camera_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_camera_url(&mut self, v: ::std::string::String) {
        self.camera_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_url(&mut self) -> &mut ::std::string::String {
        &mut self.camera_url
    }

    // Take field
    pub fn take_camera_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.camera_url, ::std::string::String::new())
    }

    // .matrix_io.vision.v1.AreaAndZoneConfig area_and_zone = 2;


    pub fn get_area_and_zone(&self) -> &AreaAndZoneConfig {
        self.area_and_zone.as_ref().unwrap_or_else(|| <AreaAndZoneConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_area_and_zone(&mut self) {
        self.area_and_zone.clear();
    }

    pub fn has_area_and_zone(&self) -> bool {
        self.area_and_zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_area_and_zone(&mut self, v: AreaAndZoneConfig) {
        self.area_and_zone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_area_and_zone(&mut self) -> &mut AreaAndZoneConfig {
        if self.area_and_zone.is_none() {
            self.area_and_zone.set_default();
        }
        self.area_and_zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_area_and_zone(&mut self) -> AreaAndZoneConfig {
        self.area_and_zone.take().unwrap_or_else(|| AreaAndZoneConfig::new())
    }
}

impl ::protobuf::Message for VehicleConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.area_and_zone {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.camera_url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.area_and_zone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.camera_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.camera_url);
        }
        if let Some(ref v) = self.area_and_zone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.camera_url.is_empty() {
            os.write_string(1, &self.camera_url)?;
        }
        if let Some(ref v) = self.area_and_zone.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VehicleConfig {
        VehicleConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "camera_url",
                |m: &VehicleConfig| { &m.camera_url },
                |m: &mut VehicleConfig| { &mut m.camera_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AreaAndZoneConfig>>(
                "area_and_zone",
                |m: &VehicleConfig| { &m.area_and_zone },
                |m: &mut VehicleConfig| { &mut m.area_and_zone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VehicleConfig>(
                "VehicleConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VehicleConfig {
        static instance: ::protobuf::rt::LazyV2<VehicleConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VehicleConfig::new)
    }
}

impl ::protobuf::Clear for VehicleConfig {
    fn clear(&mut self) {
        self.camera_url.clear();
        self.area_and_zone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VehicleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehicleConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VisionEvent {
    // message fields
    pub tag: EventTag,
    pub tracking_id: u64,
    pub session_time: f32,
    pub dwell_time: f32,
    pub area_id: u64,
    pub zone_id: u64,
    pub zone_direction: ZoneDirection,
    pub speed: f32,
    pub timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub area_name: ::std::string::String,
    pub zone_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VisionEvent {
    fn default() -> &'a VisionEvent {
        <VisionEvent as ::protobuf::Message>::default_instance()
    }
}

impl VisionEvent {
    pub fn new() -> VisionEvent {
        ::std::default::Default::default()
    }

    // .matrix_io.vision.v1.EventTag tag = 1;


    pub fn get_tag(&self) -> EventTag {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = EventTag::EVENT_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: EventTag) {
        self.tag = v;
    }

    // uint64 tracking_id = 2;


    pub fn get_tracking_id(&self) -> u64 {
        self.tracking_id
    }
    pub fn clear_tracking_id(&mut self) {
        self.tracking_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_tracking_id(&mut self, v: u64) {
        self.tracking_id = v;
    }

    // float session_time = 3;


    pub fn get_session_time(&self) -> f32 {
        self.session_time
    }
    pub fn clear_session_time(&mut self) {
        self.session_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_session_time(&mut self, v: f32) {
        self.session_time = v;
    }

    // float dwell_time = 4;


    pub fn get_dwell_time(&self) -> f32 {
        self.dwell_time
    }
    pub fn clear_dwell_time(&mut self) {
        self.dwell_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_dwell_time(&mut self, v: f32) {
        self.dwell_time = v;
    }

    // uint64 area_id = 5;


    pub fn get_area_id(&self) -> u64 {
        self.area_id
    }
    pub fn clear_area_id(&mut self) {
        self.area_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_area_id(&mut self, v: u64) {
        self.area_id = v;
    }

    // uint64 zone_id = 6;


    pub fn get_zone_id(&self) -> u64 {
        self.zone_id
    }
    pub fn clear_zone_id(&mut self) {
        self.zone_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_zone_id(&mut self, v: u64) {
        self.zone_id = v;
    }

    // .matrix_io.vision.v1.ZoneDirection zone_direction = 7;


    pub fn get_zone_direction(&self) -> ZoneDirection {
        self.zone_direction
    }
    pub fn clear_zone_direction(&mut self) {
        self.zone_direction = ZoneDirection::ZONE_DIRECTION_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_zone_direction(&mut self, v: ZoneDirection) {
        self.zone_direction = v;
    }

    // float speed = 8;


    pub fn get_speed(&self) -> f32 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = v;
    }

    // .google.protobuf.Timestamp timestamp = 9;


    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.timestamp.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.timestamp.is_none() {
            self.timestamp.set_default();
        }
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string area_name = 10;


    pub fn get_area_name(&self) -> &str {
        &self.area_name
    }
    pub fn clear_area_name(&mut self) {
        self.area_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_area_name(&mut self, v: ::std::string::String) {
        self.area_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_area_name(&mut self) -> &mut ::std::string::String {
        &mut self.area_name
    }

    // Take field
    pub fn take_area_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.area_name, ::std::string::String::new())
    }

    // string zone_name = 11;


    pub fn get_zone_name(&self) -> &str {
        &self.zone_name
    }
    pub fn clear_zone_name(&mut self) {
        self.zone_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone_name(&mut self, v: ::std::string::String) {
        self.zone_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone_name(&mut self) -> &mut ::std::string::String {
        &mut self.zone_name
    }

    // Take field
    pub fn take_zone_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VisionEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tracking_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.session_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dwell_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.area_id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.zone_id = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.zone_direction, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.speed = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamp)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.area_name)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != EventTag::EVENT_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.tag);
        }
        if self.tracking_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tracking_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.session_time != 0. {
            my_size += 5;
        }
        if self.dwell_time != 0. {
            my_size += 5;
        }
        if self.area_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.area_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.zone_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.zone_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.zone_direction != ZoneDirection::ZONE_DIRECTION_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(7, self.zone_direction);
        }
        if self.speed != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.area_name.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.area_name);
        }
        if !self.zone_name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.zone_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag != EventTag::EVENT_NOT_DEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.tag))?;
        }
        if self.tracking_id != 0 {
            os.write_uint64(2, self.tracking_id)?;
        }
        if self.session_time != 0. {
            os.write_float(3, self.session_time)?;
        }
        if self.dwell_time != 0. {
            os.write_float(4, self.dwell_time)?;
        }
        if self.area_id != 0 {
            os.write_uint64(5, self.area_id)?;
        }
        if self.zone_id != 0 {
            os.write_uint64(6, self.zone_id)?;
        }
        if self.zone_direction != ZoneDirection::ZONE_DIRECTION_NOT_DEFINED {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.zone_direction))?;
        }
        if self.speed != 0. {
            os.write_float(8, self.speed)?;
        }
        if let Some(ref v) = self.timestamp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.area_name.is_empty() {
            os.write_string(10, &self.area_name)?;
        }
        if !self.zone_name.is_empty() {
            os.write_string(11, &self.zone_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VisionEvent {
        VisionEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EventTag>>(
                "tag",
                |m: &VisionEvent| { &m.tag },
                |m: &mut VisionEvent| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tracking_id",
                |m: &VisionEvent| { &m.tracking_id },
                |m: &mut VisionEvent| { &mut m.tracking_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "session_time",
                |m: &VisionEvent| { &m.session_time },
                |m: &mut VisionEvent| { &mut m.session_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "dwell_time",
                |m: &VisionEvent| { &m.dwell_time },
                |m: &mut VisionEvent| { &mut m.dwell_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "area_id",
                |m: &VisionEvent| { &m.area_id },
                |m: &mut VisionEvent| { &mut m.area_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "zone_id",
                |m: &VisionEvent| { &m.zone_id },
                |m: &mut VisionEvent| { &mut m.zone_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ZoneDirection>>(
                "zone_direction",
                |m: &VisionEvent| { &m.zone_direction },
                |m: &mut VisionEvent| { &mut m.zone_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "speed",
                |m: &VisionEvent| { &m.speed },
                |m: &mut VisionEvent| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "timestamp",
                |m: &VisionEvent| { &m.timestamp },
                |m: &mut VisionEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "area_name",
                |m: &VisionEvent| { &m.area_name },
                |m: &mut VisionEvent| { &mut m.area_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone_name",
                |m: &VisionEvent| { &m.zone_name },
                |m: &mut VisionEvent| { &mut m.zone_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VisionEvent>(
                "VisionEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VisionEvent {
        static instance: ::protobuf::rt::LazyV2<VisionEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VisionEvent::new)
    }
}

impl ::protobuf::Clear for VisionEvent {
    fn clear(&mut self) {
        self.tag = EventTag::EVENT_NOT_DEFINED;
        self.tracking_id = 0;
        self.session_time = 0.;
        self.dwell_time = 0.;
        self.area_id = 0;
        self.zone_id = 0;
        self.zone_direction = ZoneDirection::ZONE_DIRECTION_NOT_DEFINED;
        self.speed = 0.;
        self.timestamp.clear();
        self.area_name.clear();
        self.zone_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VisionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RectangularDetection {
    // message fields
    pub algorithm: EnumDetectionAlgorithm,
    pub location: ::protobuf::SingularPtrField<Rectangle>,
    pub tag: EnumDetectionTag,
    pub confidence: f32,
    pub facial_recognition: ::protobuf::RepeatedField<FacialRecognition>,
    pub vehicle_recognition: ::protobuf::RepeatedField<VehicleRecognition>,
    pub speed: f32,
    pub image: ::std::vec::Vec<u8>,
    pub image_small: ::std::vec::Vec<u8>,
    pub field_type: ::std::string::String,
    pub tracking_id: u64,
    pub uuid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RectangularDetection {
    fn default() -> &'a RectangularDetection {
        <RectangularDetection as ::protobuf::Message>::default_instance()
    }
}

impl RectangularDetection {
    pub fn new() -> RectangularDetection {
        ::std::default::Default::default()
    }

    // .matrix_io.vision.v1.EnumDetectionAlgorithm algorithm = 1;


    pub fn get_algorithm(&self) -> EnumDetectionAlgorithm {
        self.algorithm
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm = EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EnumDetectionAlgorithm) {
        self.algorithm = v;
    }

    // .matrix_io.vision.v1.Rectangle location = 2;


    pub fn get_location(&self) -> &Rectangle {
        self.location.as_ref().unwrap_or_else(|| <Rectangle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Rectangle) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Rectangle {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Rectangle {
        self.location.take().unwrap_or_else(|| Rectangle::new())
    }

    // .matrix_io.vision.v1.EnumDetectionTag tag = 3;


    pub fn get_tag(&self) -> EnumDetectionTag {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = EnumDetectionTag::DETECTION_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: EnumDetectionTag) {
        self.tag = v;
    }

    // float confidence = 4;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }

    // repeated .matrix_io.vision.v1.FacialRecognition facial_recognition = 5;


    pub fn get_facial_recognition(&self) -> &[FacialRecognition] {
        &self.facial_recognition
    }
    pub fn clear_facial_recognition(&mut self) {
        self.facial_recognition.clear();
    }

    // Param is passed by value, moved
    pub fn set_facial_recognition(&mut self, v: ::protobuf::RepeatedField<FacialRecognition>) {
        self.facial_recognition = v;
    }

    // Mutable pointer to the field.
    pub fn mut_facial_recognition(&mut self) -> &mut ::protobuf::RepeatedField<FacialRecognition> {
        &mut self.facial_recognition
    }

    // Take field
    pub fn take_facial_recognition(&mut self) -> ::protobuf::RepeatedField<FacialRecognition> {
        ::std::mem::replace(&mut self.facial_recognition, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.VehicleRecognition vehicle_recognition = 9;


    pub fn get_vehicle_recognition(&self) -> &[VehicleRecognition] {
        &self.vehicle_recognition
    }
    pub fn clear_vehicle_recognition(&mut self) {
        self.vehicle_recognition.clear();
    }

    // Param is passed by value, moved
    pub fn set_vehicle_recognition(&mut self, v: ::protobuf::RepeatedField<VehicleRecognition>) {
        self.vehicle_recognition = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vehicle_recognition(&mut self) -> &mut ::protobuf::RepeatedField<VehicleRecognition> {
        &mut self.vehicle_recognition
    }

    // Take field
    pub fn take_vehicle_recognition(&mut self) -> ::protobuf::RepeatedField<VehicleRecognition> {
        ::std::mem::replace(&mut self.vehicle_recognition, ::protobuf::RepeatedField::new())
    }

    // float speed = 10;


    pub fn get_speed(&self) -> f32 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = v;
    }

    // bytes image = 6;


    pub fn get_image(&self) -> &[u8] {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.image, ::std::vec::Vec::new())
    }

    // bytes image_small = 7;


    pub fn get_image_small(&self) -> &[u8] {
        &self.image_small
    }
    pub fn clear_image_small(&mut self) {
        self.image_small.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_small(&mut self, v: ::std::vec::Vec<u8>) {
        self.image_small = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_small(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.image_small
    }

    // Take field
    pub fn take_image_small(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.image_small, ::std::vec::Vec::new())
    }

    // string type = 12;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // uint64 tracking_id = 8;


    pub fn get_tracking_id(&self) -> u64 {
        self.tracking_id
    }
    pub fn clear_tracking_id(&mut self) {
        self.tracking_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_tracking_id(&mut self, v: u64) {
        self.tracking_id = v;
    }

    // string uuid = 11;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RectangularDetection {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.facial_recognition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle_recognition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.algorithm, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.facial_recognition)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vehicle_recognition)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.speed = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.image_small)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tracking_id = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.algorithm != EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.algorithm);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tag != EnumDetectionTag::DETECTION_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(3, self.tag);
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        for value in &self.facial_recognition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.vehicle_recognition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.speed != 0. {
            my_size += 5;
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.image);
        }
        if !self.image_small.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.image_small);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.field_type);
        }
        if self.tracking_id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tracking_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.algorithm != EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.algorithm))?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tag != EnumDetectionTag::DETECTION_NOT_DEFINED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.tag))?;
        }
        if self.confidence != 0. {
            os.write_float(4, self.confidence)?;
        }
        for v in &self.facial_recognition {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.vehicle_recognition {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.speed != 0. {
            os.write_float(10, self.speed)?;
        }
        if !self.image.is_empty() {
            os.write_bytes(6, &self.image)?;
        }
        if !self.image_small.is_empty() {
            os.write_bytes(7, &self.image_small)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(12, &self.field_type)?;
        }
        if self.tracking_id != 0 {
            os.write_uint64(8, self.tracking_id)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(11, &self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RectangularDetection {
        RectangularDetection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnumDetectionAlgorithm>>(
                "algorithm",
                |m: &RectangularDetection| { &m.algorithm },
                |m: &mut RectangularDetection| { &mut m.algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rectangle>>(
                "location",
                |m: &RectangularDetection| { &m.location },
                |m: &mut RectangularDetection| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnumDetectionTag>>(
                "tag",
                |m: &RectangularDetection| { &m.tag },
                |m: &mut RectangularDetection| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "confidence",
                |m: &RectangularDetection| { &m.confidence },
                |m: &mut RectangularDetection| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FacialRecognition>>(
                "facial_recognition",
                |m: &RectangularDetection| { &m.facial_recognition },
                |m: &mut RectangularDetection| { &mut m.facial_recognition },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VehicleRecognition>>(
                "vehicle_recognition",
                |m: &RectangularDetection| { &m.vehicle_recognition },
                |m: &mut RectangularDetection| { &mut m.vehicle_recognition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "speed",
                |m: &RectangularDetection| { &m.speed },
                |m: &mut RectangularDetection| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image",
                |m: &RectangularDetection| { &m.image },
                |m: &mut RectangularDetection| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image_small",
                |m: &RectangularDetection| { &m.image_small },
                |m: &mut RectangularDetection| { &mut m.image_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &RectangularDetection| { &m.field_type },
                |m: &mut RectangularDetection| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tracking_id",
                |m: &RectangularDetection| { &m.tracking_id },
                |m: &mut RectangularDetection| { &mut m.tracking_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &RectangularDetection| { &m.uuid },
                |m: &mut RectangularDetection| { &mut m.uuid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RectangularDetection>(
                "RectangularDetection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RectangularDetection {
        static instance: ::protobuf::rt::LazyV2<RectangularDetection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RectangularDetection::new)
    }
}

impl ::protobuf::Clear for RectangularDetection {
    fn clear(&mut self) {
        self.algorithm = EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED;
        self.location.clear();
        self.tag = EnumDetectionTag::DETECTION_NOT_DEFINED;
        self.confidence = 0.;
        self.facial_recognition.clear();
        self.vehicle_recognition.clear();
        self.speed = 0.;
        self.image.clear();
        self.image_small.clear();
        self.field_type.clear();
        self.tracking_id = 0;
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RectangularDetection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RectangularDetection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageList {
    // message fields
    pub image_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub frames_per_second: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageList {
    fn default() -> &'a ImageList {
        <ImageList as ::protobuf::Message>::default_instance()
    }
}

impl ImageList {
    pub fn new() -> ImageList {
        ::std::default::Default::default()
    }

    // repeated bytes image_data = 1;


    pub fn get_image_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.image_data
    }
    pub fn clear_image_data(&mut self) {
        self.image_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.image_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_image_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.image_data
    }

    // Take field
    pub fn take_image_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.image_data, ::protobuf::RepeatedField::new())
    }

    // int32 frames_per_second = 2;


    pub fn get_frames_per_second(&self) -> i32 {
        self.frames_per_second
    }
    pub fn clear_frames_per_second(&mut self) {
        self.frames_per_second = 0;
    }

    // Param is passed by value, moved
    pub fn set_frames_per_second(&mut self, v: i32) {
        self.frames_per_second = v;
    }
}

impl ::protobuf::Message for ImageList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.image_data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.frames_per_second = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.image_data {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if self.frames_per_second != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frames_per_second, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.image_data {
            os.write_bytes(1, &v)?;
        };
        if self.frames_per_second != 0 {
            os.write_int32(2, self.frames_per_second)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageList {
        ImageList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image_data",
                |m: &ImageList| { &m.image_data },
                |m: &mut ImageList| { &mut m.image_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "frames_per_second",
                |m: &ImageList| { &m.frames_per_second },
                |m: &mut ImageList| { &mut m.frames_per_second },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageList>(
                "ImageList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageList {
        static instance: ::protobuf::rt::LazyV2<ImageList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageList::new)
    }
}

impl ::protobuf::Clear for ImageList {
    fn clear(&mut self) {
        self.image_data.clear();
        self.frames_per_second = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Video {
    // message fields
    pub video_data: ::std::vec::Vec<u8>,
    pub codec: EnumVideoCodec,
    pub tag: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Video {
    fn default() -> &'a Video {
        <Video as ::protobuf::Message>::default_instance()
    }
}

impl Video {
    pub fn new() -> Video {
        ::std::default::Default::default()
    }

    // bytes video_data = 1;


    pub fn get_video_data(&self) -> &[u8] {
        &self.video_data
    }
    pub fn clear_video_data(&mut self) {
        self.video_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_video_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.video_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.video_data
    }

    // Take field
    pub fn take_video_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.video_data, ::std::vec::Vec::new())
    }

    // .matrix_io.vision.v1.EnumVideoCodec codec = 2;


    pub fn get_codec(&self) -> EnumVideoCodec {
        self.codec
    }
    pub fn clear_codec(&mut self) {
        self.codec = EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EnumVideoCodec) {
        self.codec = v;
    }

    // repeated string tag = 3;


    pub fn get_tag(&self) -> &[::std::string::String] {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tag, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Video {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.video_data)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.codec, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.video_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.video_data);
        }
        if self.codec != EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(2, self.codec);
        }
        for value in &self.tag {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.video_data.is_empty() {
            os.write_bytes(1, &self.video_data)?;
        }
        if self.codec != EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.codec))?;
        }
        for v in &self.tag {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Video {
        Video::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "video_data",
                |m: &Video| { &m.video_data },
                |m: &mut Video| { &mut m.video_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnumVideoCodec>>(
                "codec",
                |m: &Video| { &m.codec },
                |m: &mut Video| { &mut m.codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &Video| { &m.tag },
                |m: &mut Video| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Video>(
                "Video",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Video {
        static instance: ::protobuf::rt::LazyV2<Video> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Video::new)
    }
}

impl ::protobuf::Clear for Video {
    fn clear(&mut self) {
        self.video_data.clear();
        self.codec = EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED;
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Video {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Video {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    pub image: ::std::vec::Vec<u8>,
    pub format: ImageFormat,
    pub size: ::protobuf::SingularPtrField<Size>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // bytes image = 1;


    pub fn get_image(&self) -> &[u8] {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.image, ::std::vec::Vec::new())
    }

    // .matrix_io.vision.v1.ImageFormat format = 2;


    pub fn get_format(&self) -> ImageFormat {
        self.format
    }
    pub fn clear_format(&mut self) {
        self.format = ImageFormat::IMAGE_FORMAT_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ImageFormat) {
        self.format = v;
    }

    // .matrix_io.vision.v1.Size size = 3;


    pub fn get_size(&self) -> &Size {
        self.size.as_ref().unwrap_or_else(|| <Size as ::protobuf::Message>::default_instance())
    }
    pub fn clear_size(&mut self) {
        self.size.clear();
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Size) {
        self.size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&mut self) -> &mut Size {
        if self.size.is_none() {
            self.size.set_default();
        }
        self.size.as_mut().unwrap()
    }

    // Take field
    pub fn take_size(&mut self) -> Size {
        self.size.take().unwrap_or_else(|| Size::new())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.size {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.image);
        }
        if self.format != ImageFormat::IMAGE_FORMAT_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(2, self.format);
        }
        if let Some(ref v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image.is_empty() {
            os.write_bytes(1, &self.image)?;
        }
        if self.format != ImageFormat::IMAGE_FORMAT_NOT_DEFINED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.format))?;
        }
        if let Some(ref v) = self.size.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image",
                |m: &Image| { &m.image },
                |m: &mut Image| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImageFormat>>(
                "format",
                |m: &Image| { &m.format },
                |m: &mut Image| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Size>>(
                "size",
                |m: &Image| { &m.size },
                |m: &mut Image| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.image.clear();
        self.format = ImageFormat::IMAGE_FORMAT_NOT_DEFINED;
        self.size.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FrameData {
    // message fields
    pub id: u64,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub sections: ::std::collections::HashMap<::std::string::String, f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FrameData {
    fn default() -> &'a FrameData {
        <FrameData as ::protobuf::Message>::default_instance()
    }
}

impl FrameData {
    pub fn new() -> FrameData {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // .google.protobuf.Timestamp start_time = 2;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 3;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .matrix_io.vision.v1.FrameData.sections_MapEntry sections = 4;


    pub fn get_sections(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
        &self.sections
    }
    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
        ::std::mem::replace(&mut self.sections, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for FrameData {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeFloat>(wire_type, is, &mut self.sections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeFloat>(4, &self.sections);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeFloat>(4, &self.sections, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FrameData {
        FrameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &FrameData| { &m.id },
                |m: &mut FrameData| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &FrameData| { &m.start_time },
                |m: &mut FrameData| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &FrameData| { &m.end_time },
                |m: &mut FrameData| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeFloat>(
                "sections",
                |m: &FrameData| { &m.sections },
                |m: &mut FrameData| { &mut m.sections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FrameData>(
                "FrameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FrameData {
        static instance: ::protobuf::rt::LazyV2<FrameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FrameData::new)
    }
}

impl ::protobuf::Clear for FrameData {
    fn clear(&mut self) {
        self.id = 0;
        self.start_time.clear();
        self.end_time.clear();
        self.sections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FrameDataList {
    // message fields
    pub frames: ::protobuf::RepeatedField<FrameData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FrameDataList {
    fn default() -> &'a FrameDataList {
        <FrameDataList as ::protobuf::Message>::default_instance()
    }
}

impl FrameDataList {
    pub fn new() -> FrameDataList {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.vision.v1.FrameData frames = 1;


    pub fn get_frames(&self) -> &[FrameData] {
        &self.frames
    }
    pub fn clear_frames(&mut self) {
        self.frames.clear();
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: ::protobuf::RepeatedField<FrameData>) {
        self.frames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frames(&mut self) -> &mut ::protobuf::RepeatedField<FrameData> {
        &mut self.frames
    }

    // Take field
    pub fn take_frames(&mut self) -> ::protobuf::RepeatedField<FrameData> {
        ::std::mem::replace(&mut self.frames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FrameDataList {
    fn is_initialized(&self) -> bool {
        for v in &self.frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.frames {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FrameDataList {
        FrameDataList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameData>>(
                "frames",
                |m: &FrameDataList| { &m.frames },
                |m: &mut FrameDataList| { &mut m.frames },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FrameDataList>(
                "FrameDataList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FrameDataList {
        static instance: ::protobuf::rt::LazyV2<FrameDataList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FrameDataList::new)
    }
}

impl ::protobuf::Clear for FrameDataList {
    fn clear(&mut self) {
        self.frames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameDataList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameDataList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VisionResult {
    // message fields
    pub rect_detection: ::protobuf::RepeatedField<RectangularDetection>,
    pub vision_event: ::protobuf::RepeatedField<VisionEvent>,
    pub result_image: ::protobuf::SingularPtrField<Image>,
    pub result_image_small: ::protobuf::SingularPtrField<Image>,
    pub image: ::std::vec::Vec<u8>,
    pub image_small: ::std::vec::Vec<u8>,
    pub uuid: ::std::string::String,
    pub frame_data: ::protobuf::SingularPtrField<FrameData>,
    pub moment_of_day: MomentOfDay,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VisionResult {
    fn default() -> &'a VisionResult {
        <VisionResult as ::protobuf::Message>::default_instance()
    }
}

impl VisionResult {
    pub fn new() -> VisionResult {
        ::std::default::Default::default()
    }

    // repeated .matrix_io.vision.v1.RectangularDetection rect_detection = 1;


    pub fn get_rect_detection(&self) -> &[RectangularDetection] {
        &self.rect_detection
    }
    pub fn clear_rect_detection(&mut self) {
        self.rect_detection.clear();
    }

    // Param is passed by value, moved
    pub fn set_rect_detection(&mut self, v: ::protobuf::RepeatedField<RectangularDetection>) {
        self.rect_detection = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rect_detection(&mut self) -> &mut ::protobuf::RepeatedField<RectangularDetection> {
        &mut self.rect_detection
    }

    // Take field
    pub fn take_rect_detection(&mut self) -> ::protobuf::RepeatedField<RectangularDetection> {
        ::std::mem::replace(&mut self.rect_detection, ::protobuf::RepeatedField::new())
    }

    // repeated .matrix_io.vision.v1.VisionEvent vision_event = 4;


    pub fn get_vision_event(&self) -> &[VisionEvent] {
        &self.vision_event
    }
    pub fn clear_vision_event(&mut self) {
        self.vision_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_vision_event(&mut self, v: ::protobuf::RepeatedField<VisionEvent>) {
        self.vision_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vision_event(&mut self) -> &mut ::protobuf::RepeatedField<VisionEvent> {
        &mut self.vision_event
    }

    // Take field
    pub fn take_vision_event(&mut self) -> ::protobuf::RepeatedField<VisionEvent> {
        ::std::mem::replace(&mut self.vision_event, ::protobuf::RepeatedField::new())
    }

    // .matrix_io.vision.v1.Image result_image = 5;


    pub fn get_result_image(&self) -> &Image {
        self.result_image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result_image(&mut self) {
        self.result_image.clear();
    }

    pub fn has_result_image(&self) -> bool {
        self.result_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_image(&mut self, v: Image) {
        self.result_image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_image(&mut self) -> &mut Image {
        if self.result_image.is_none() {
            self.result_image.set_default();
        }
        self.result_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_image(&mut self) -> Image {
        self.result_image.take().unwrap_or_else(|| Image::new())
    }

    // .matrix_io.vision.v1.Image result_image_small = 6;


    pub fn get_result_image_small(&self) -> &Image {
        self.result_image_small.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result_image_small(&mut self) {
        self.result_image_small.clear();
    }

    pub fn has_result_image_small(&self) -> bool {
        self.result_image_small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_image_small(&mut self, v: Image) {
        self.result_image_small = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_image_small(&mut self) -> &mut Image {
        if self.result_image_small.is_none() {
            self.result_image_small.set_default();
        }
        self.result_image_small.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_image_small(&mut self) -> Image {
        self.result_image_small.take().unwrap_or_else(|| Image::new())
    }

    // bytes image = 2;


    pub fn get_image(&self) -> &[u8] {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.image, ::std::vec::Vec::new())
    }

    // bytes image_small = 3;


    pub fn get_image_small(&self) -> &[u8] {
        &self.image_small
    }
    pub fn clear_image_small(&mut self) {
        self.image_small.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_small(&mut self, v: ::std::vec::Vec<u8>) {
        self.image_small = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_small(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.image_small
    }

    // Take field
    pub fn take_image_small(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.image_small, ::std::vec::Vec::new())
    }

    // string uuid = 7;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // .matrix_io.vision.v1.FrameData frame_data = 8;


    pub fn get_frame_data(&self) -> &FrameData {
        self.frame_data.as_ref().unwrap_or_else(|| <FrameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frame_data(&mut self) {
        self.frame_data.clear();
    }

    pub fn has_frame_data(&self) -> bool {
        self.frame_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_data(&mut self, v: FrameData) {
        self.frame_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frame_data(&mut self) -> &mut FrameData {
        if self.frame_data.is_none() {
            self.frame_data.set_default();
        }
        self.frame_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_frame_data(&mut self) -> FrameData {
        self.frame_data.take().unwrap_or_else(|| FrameData::new())
    }

    // .matrix_io.vision.v1.MomentOfDay moment_of_day = 9;


    pub fn get_moment_of_day(&self) -> MomentOfDay {
        self.moment_of_day
    }
    pub fn clear_moment_of_day(&mut self) {
        self.moment_of_day = MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED;
    }

    // Param is passed by value, moved
    pub fn set_moment_of_day(&mut self, v: MomentOfDay) {
        self.moment_of_day = v;
    }
}

impl ::protobuf::Message for VisionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.rect_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vision_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result_image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result_image_small {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frame_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rect_detection)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vision_event)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_image)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_image_small)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.image_small)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frame_data)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.moment_of_day, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rect_detection {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.vision_event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.result_image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result_image_small.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.image);
        }
        if !self.image_small.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.image_small);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.uuid);
        }
        if let Some(ref v) = self.frame_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.moment_of_day != MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED {
            my_size += ::protobuf::rt::enum_size(9, self.moment_of_day);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rect_detection {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.vision_event {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.result_image.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result_image_small.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.image.is_empty() {
            os.write_bytes(2, &self.image)?;
        }
        if !self.image_small.is_empty() {
            os.write_bytes(3, &self.image_small)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(7, &self.uuid)?;
        }
        if let Some(ref v) = self.frame_data.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.moment_of_day != MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.moment_of_day))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VisionResult {
        VisionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RectangularDetection>>(
                "rect_detection",
                |m: &VisionResult| { &m.rect_detection },
                |m: &mut VisionResult| { &mut m.rect_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VisionEvent>>(
                "vision_event",
                |m: &VisionResult| { &m.vision_event },
                |m: &mut VisionResult| { &mut m.vision_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "result_image",
                |m: &VisionResult| { &m.result_image },
                |m: &mut VisionResult| { &mut m.result_image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "result_image_small",
                |m: &VisionResult| { &m.result_image_small },
                |m: &mut VisionResult| { &mut m.result_image_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image",
                |m: &VisionResult| { &m.image },
                |m: &mut VisionResult| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image_small",
                |m: &VisionResult| { &m.image_small },
                |m: &mut VisionResult| { &mut m.image_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &VisionResult| { &m.uuid },
                |m: &mut VisionResult| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameData>>(
                "frame_data",
                |m: &VisionResult| { &m.frame_data },
                |m: &mut VisionResult| { &mut m.frame_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MomentOfDay>>(
                "moment_of_day",
                |m: &VisionResult| { &m.moment_of_day },
                |m: &mut VisionResult| { &mut m.moment_of_day },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VisionResult>(
                "VisionResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VisionResult {
        static instance: ::protobuf::rt::LazyV2<VisionResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VisionResult::new)
    }
}

impl ::protobuf::Clear for VisionResult {
    fn clear(&mut self) {
        self.rect_detection.clear();
        self.vision_event.clear();
        self.result_image.clear();
        self.result_image_small.clear();
        self.image.clear();
        self.image_small.clear();
        self.uuid.clear();
        self.frame_data.clear();
        self.moment_of_day = MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VisionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnumFacialRecognitionTag {
    FACIAL_RECOGNITION_NOT_DEFINED = 0,
    AGE = 1,
    EMOTION = 2,
    GENDER = 3,
    FACE_ID = 4,
    HEAD_POSE = 5,
    FACE_FEATURES = 6,
    FACE_DESCRIPTOR = 7,
    IS_FACE = 8,
    HAVE_GLASS = 9,
    BEARD = 10,
    TYPE_GLASS = 11,
}

impl ::protobuf::ProtobufEnum for EnumFacialRecognitionTag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnumFacialRecognitionTag> {
        match value {
            0 => ::std::option::Option::Some(EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED),
            1 => ::std::option::Option::Some(EnumFacialRecognitionTag::AGE),
            2 => ::std::option::Option::Some(EnumFacialRecognitionTag::EMOTION),
            3 => ::std::option::Option::Some(EnumFacialRecognitionTag::GENDER),
            4 => ::std::option::Option::Some(EnumFacialRecognitionTag::FACE_ID),
            5 => ::std::option::Option::Some(EnumFacialRecognitionTag::HEAD_POSE),
            6 => ::std::option::Option::Some(EnumFacialRecognitionTag::FACE_FEATURES),
            7 => ::std::option::Option::Some(EnumFacialRecognitionTag::FACE_DESCRIPTOR),
            8 => ::std::option::Option::Some(EnumFacialRecognitionTag::IS_FACE),
            9 => ::std::option::Option::Some(EnumFacialRecognitionTag::HAVE_GLASS),
            10 => ::std::option::Option::Some(EnumFacialRecognitionTag::BEARD),
            11 => ::std::option::Option::Some(EnumFacialRecognitionTag::TYPE_GLASS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnumFacialRecognitionTag] = &[
            EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED,
            EnumFacialRecognitionTag::AGE,
            EnumFacialRecognitionTag::EMOTION,
            EnumFacialRecognitionTag::GENDER,
            EnumFacialRecognitionTag::FACE_ID,
            EnumFacialRecognitionTag::HEAD_POSE,
            EnumFacialRecognitionTag::FACE_FEATURES,
            EnumFacialRecognitionTag::FACE_DESCRIPTOR,
            EnumFacialRecognitionTag::IS_FACE,
            EnumFacialRecognitionTag::HAVE_GLASS,
            EnumFacialRecognitionTag::BEARD,
            EnumFacialRecognitionTag::TYPE_GLASS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EnumFacialRecognitionTag>("EnumFacialRecognitionTag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EnumFacialRecognitionTag {
}

impl ::std::default::Default for EnumFacialRecognitionTag {
    fn default() -> Self {
        EnumFacialRecognitionTag::FACIAL_RECOGNITION_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumFacialRecognitionTag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnumVehicleRecognitionTag {
    VEHICLE_RECOGNITION_NOT_DEFINED = 0,
    FAMILY_CAR = 1,
}

impl ::protobuf::ProtobufEnum for EnumVehicleRecognitionTag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnumVehicleRecognitionTag> {
        match value {
            0 => ::std::option::Option::Some(EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED),
            1 => ::std::option::Option::Some(EnumVehicleRecognitionTag::FAMILY_CAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnumVehicleRecognitionTag] = &[
            EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED,
            EnumVehicleRecognitionTag::FAMILY_CAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EnumVehicleRecognitionTag>("EnumVehicleRecognitionTag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EnumVehicleRecognitionTag {
}

impl ::std::default::Default for EnumVehicleRecognitionTag {
    fn default() -> Self {
        EnumVehicleRecognitionTag::VEHICLE_RECOGNITION_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumVehicleRecognitionTag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ZoneDirection {
    ZONE_DIRECTION_NOT_DEFINED = 0,
    FORWARD = 1,
    BACKWARD = 2,
}

impl ::protobuf::ProtobufEnum for ZoneDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ZoneDirection> {
        match value {
            0 => ::std::option::Option::Some(ZoneDirection::ZONE_DIRECTION_NOT_DEFINED),
            1 => ::std::option::Option::Some(ZoneDirection::FORWARD),
            2 => ::std::option::Option::Some(ZoneDirection::BACKWARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ZoneDirection] = &[
            ZoneDirection::ZONE_DIRECTION_NOT_DEFINED,
            ZoneDirection::FORWARD,
            ZoneDirection::BACKWARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ZoneDirection>("ZoneDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ZoneDirection {
}

impl ::std::default::Default for ZoneDirection {
    fn default() -> Self {
        ZoneDirection::ZONE_DIRECTION_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for ZoneDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventTag {
    EVENT_NOT_DEFINED = 0,
    TRACKING_START = 1,
    TRACKING_END = 2,
    AREA_ENTER = 3,
    AREA_EXIT = 4,
    ZONE_ENTER = 5,
    ZONE_EXIT = 6,
}

impl ::protobuf::ProtobufEnum for EventTag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventTag> {
        match value {
            0 => ::std::option::Option::Some(EventTag::EVENT_NOT_DEFINED),
            1 => ::std::option::Option::Some(EventTag::TRACKING_START),
            2 => ::std::option::Option::Some(EventTag::TRACKING_END),
            3 => ::std::option::Option::Some(EventTag::AREA_ENTER),
            4 => ::std::option::Option::Some(EventTag::AREA_EXIT),
            5 => ::std::option::Option::Some(EventTag::ZONE_ENTER),
            6 => ::std::option::Option::Some(EventTag::ZONE_EXIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventTag] = &[
            EventTag::EVENT_NOT_DEFINED,
            EventTag::TRACKING_START,
            EventTag::TRACKING_END,
            EventTag::AREA_ENTER,
            EventTag::AREA_EXIT,
            EventTag::ZONE_ENTER,
            EventTag::ZONE_EXIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EventTag>("EventTag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EventTag {
}

impl ::std::default::Default for EventTag {
    fn default() -> Self {
        EventTag::EVENT_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnumDetectionTag {
    DETECTION_NOT_DEFINED = 0,
    FACE = 1,
    HAND_THUMB = 2,
    HAND_PALM = 3,
    HAND_PINCH = 4,
    HAND_FIST = 5,
    PERSON = 6,
}

impl ::protobuf::ProtobufEnum for EnumDetectionTag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnumDetectionTag> {
        match value {
            0 => ::std::option::Option::Some(EnumDetectionTag::DETECTION_NOT_DEFINED),
            1 => ::std::option::Option::Some(EnumDetectionTag::FACE),
            2 => ::std::option::Option::Some(EnumDetectionTag::HAND_THUMB),
            3 => ::std::option::Option::Some(EnumDetectionTag::HAND_PALM),
            4 => ::std::option::Option::Some(EnumDetectionTag::HAND_PINCH),
            5 => ::std::option::Option::Some(EnumDetectionTag::HAND_FIST),
            6 => ::std::option::Option::Some(EnumDetectionTag::PERSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnumDetectionTag] = &[
            EnumDetectionTag::DETECTION_NOT_DEFINED,
            EnumDetectionTag::FACE,
            EnumDetectionTag::HAND_THUMB,
            EnumDetectionTag::HAND_PALM,
            EnumDetectionTag::HAND_PINCH,
            EnumDetectionTag::HAND_FIST,
            EnumDetectionTag::PERSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EnumDetectionTag>("EnumDetectionTag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EnumDetectionTag {
}

impl ::std::default::Default for EnumDetectionTag {
    fn default() -> Self {
        EnumDetectionTag::DETECTION_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumDetectionTag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnumDetectionAlgorithm {
    DETECTION_ALGORITHM_NOT_DEFINED = 0,
    DEFAULT = 1,
    FIRST_ALTERNATIVE = 2,
}

impl ::protobuf::ProtobufEnum for EnumDetectionAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnumDetectionAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED),
            1 => ::std::option::Option::Some(EnumDetectionAlgorithm::DEFAULT),
            2 => ::std::option::Option::Some(EnumDetectionAlgorithm::FIRST_ALTERNATIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnumDetectionAlgorithm] = &[
            EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED,
            EnumDetectionAlgorithm::DEFAULT,
            EnumDetectionAlgorithm::FIRST_ALTERNATIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EnumDetectionAlgorithm>("EnumDetectionAlgorithm", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EnumDetectionAlgorithm {
}

impl ::std::default::Default for EnumDetectionAlgorithm {
    fn default() -> Self {
        EnumDetectionAlgorithm::DETECTION_ALGORITHM_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumDetectionAlgorithm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnumVideoCodec {
    VIDEO_CODEC_NOT_DEFINED = 0,
    UNDEFINED_VIDEO_CODEC = 1,
    H264 = 2,
    MP4V = 3,
    RV24 = 4,
    VP8 = 5,
    VP9 = 6,
}

impl ::protobuf::ProtobufEnum for EnumVideoCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnumVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED),
            1 => ::std::option::Option::Some(EnumVideoCodec::UNDEFINED_VIDEO_CODEC),
            2 => ::std::option::Option::Some(EnumVideoCodec::H264),
            3 => ::std::option::Option::Some(EnumVideoCodec::MP4V),
            4 => ::std::option::Option::Some(EnumVideoCodec::RV24),
            5 => ::std::option::Option::Some(EnumVideoCodec::VP8),
            6 => ::std::option::Option::Some(EnumVideoCodec::VP9),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnumVideoCodec] = &[
            EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED,
            EnumVideoCodec::UNDEFINED_VIDEO_CODEC,
            EnumVideoCodec::H264,
            EnumVideoCodec::MP4V,
            EnumVideoCodec::RV24,
            EnumVideoCodec::VP8,
            EnumVideoCodec::VP9,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EnumVideoCodec>("EnumVideoCodec", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EnumVideoCodec {
}

impl ::std::default::Default for EnumVideoCodec {
    fn default() -> Self {
        EnumVideoCodec::VIDEO_CODEC_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumVideoCodec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImageFormat {
    IMAGE_FORMAT_NOT_DEFINED = 0,
    UNSPECIFIED = 1,
    FORMAT_8URGB = 2,
    FORMAT_8UBGR = 3,
    FORMAT_8U = 4,
}

impl ::protobuf::ProtobufEnum for ImageFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageFormat> {
        match value {
            0 => ::std::option::Option::Some(ImageFormat::IMAGE_FORMAT_NOT_DEFINED),
            1 => ::std::option::Option::Some(ImageFormat::UNSPECIFIED),
            2 => ::std::option::Option::Some(ImageFormat::FORMAT_8URGB),
            3 => ::std::option::Option::Some(ImageFormat::FORMAT_8UBGR),
            4 => ::std::option::Option::Some(ImageFormat::FORMAT_8U),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImageFormat] = &[
            ImageFormat::IMAGE_FORMAT_NOT_DEFINED,
            ImageFormat::UNSPECIFIED,
            ImageFormat::FORMAT_8URGB,
            ImageFormat::FORMAT_8UBGR,
            ImageFormat::FORMAT_8U,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ImageFormat>("ImageFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ImageFormat {
}

impl ::std::default::Default for ImageFormat {
    fn default() -> Self {
        ImageFormat::IMAGE_FORMAT_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MomentOfDay {
    MOMENT_OF_DAY_NOT_DEFINED = 0,
    DAY = 1,
    NIGHT = 2,
}

impl ::protobuf::ProtobufEnum for MomentOfDay {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MomentOfDay> {
        match value {
            0 => ::std::option::Option::Some(MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED),
            1 => ::std::option::Option::Some(MomentOfDay::DAY),
            2 => ::std::option::Option::Some(MomentOfDay::NIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MomentOfDay] = &[
            MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED,
            MomentOfDay::DAY,
            MomentOfDay::NIGHT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MomentOfDay>("MomentOfDay", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MomentOfDay {
}

impl ::std::default::Default for MomentOfDay {
    fn default() -> Self {
        MomentOfDay::MOMENT_OF_DAY_NOT_DEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for MomentOfDay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20matrix_io/vision/v1/vision.proto\x12\x13matrix_io.vision.v1\x1a\
    \x1fgoogle/protobuf/timestamp.proto\")\n\x05Point\x12\x0e\n\x01x\x18\x01\
    \x20\x01(\x02R\x01xB\0\x12\x0e\n\x01y\x18\x02\x20\x01(\x02R\x01yB\0:\0\"\
    :\n\x04Size\x12\x16\n\x05width\x18\x01\x20\x01(\x05R\x05widthB\0\x12\x18\
    \n\x06height\x18\x02\x20\x01(\x05R\x06heightB\0:\0\"_\n\tRectangle\x12\
    \x0e\n\x01x\x18\x01\x20\x01(\x02R\x01xB\0\x12\x0e\n\x01y\x18\x02\x20\x01\
    (\x02R\x01yB\0\x12\x16\n\x05width\x18\x03\x20\x01(\x02R\x05widthB\0\x12\
    \x18\n\x06height\x18\x04\x20\x01(\x02R\x06heightB\0:\0\"\xd8\x01\n\x12Ve\
    hicleRecognition\x12\x14\n\x04type\x18\x01\x20\x01(\tR\x04typeB\0\x12\
    \x16\n\x05brand\x18\x02\x20\x01(\tR\x05brandB\0\x12\x16\n\x05model\x18\
    \x03\x20\x01(\tR\x05modelB\0\x12\x14\n\x04year\x18\x04\x20\x01(\x05R\x04\
    yearB\0\x12B\n\x03tag\x18\x05\x20\x01(\x0e2..matrix_io.vision.v1.EnumVeh\
    icleRecognitionTagR\x03tagB\0\x12\x20\n\nconfidence\x18\x06\x20\x01(\x02\
    R\nconfidenceB\0:\0\"\xa8\x0b\n\x11FacialRecognition\x12A\n\x03tag\x18\
    \x01\x20\x01(\x0e2-.matrix_io.vision.v1.EnumFacialRecognitionTagR\x03tag\
    B\0\x12\x20\n\nconfidence\x18\x02\x20\x01(\x02R\nconfidenceB\0\x12\x12\n\
    \x03age\x18\x03\x20\x01(\x05R\x03ageB\0\x12N\n\tage_class\x18\r\x20\x01(\
    \x0e2/.matrix_io.vision.v1.FacialRecognition.AgeClassR\x08ageClassB\0\
    \x12G\n\x06gender\x18\x04\x20\x01(\x0e2-.matrix_io.vision.v1.FacialRecog\
    nition.GenderR\x06genderB\0\x12J\n\x07emotion\x18\x05\x20\x01(\x0e2..mat\
    rix_io.vision.v1.FacialRecognition.EmotionR\x07emotionB\0\x12+\n\x0fface\
    _descriptor\x18\x06\x20\x03(\x02R\x0efaceDescriptorB\x02\x10\x01\x12\x19\
    \n\x07face_id\x18\x07\x20\x01(\tR\x06faceIdB\0\x12\x1b\n\x08pose_yaw\x18\
    \x08\x20\x01(\x02R\x07poseYawB\0\x12\x1d\n\tpose_roll\x18\t\x20\x01(\x02\
    R\x08poseRollB\0\x12\x1f\n\npose_pitch\x18\n\x20\x01(\x02R\tposePitchB\0\
    \x12\x1f\n\nis_looking\x18\x0e\x20\x01(\x08R\tisLookingB\0\x12^\n\rbasic\
    _feature\x18\x0b\x20\x01(\x0b27.matrix_io.vision.v1.FacialRecognition.Ba\
    sicFaceFeatureR\x0cbasicFeatureB\0\x12\x19\n\x07is_face\x18\x0c\x20\x01(\
    \x08R\x06isFaceB\0\x12\x1f\n\nhave_glass\x18\x0f\x20\x01(\x08R\thaveGlas\
    sB\0\x12\x16\n\x05beard\x18\x10\x20\x01(\x08R\x05beardB\0\x12J\n\x07glas\
    ses\x18\x11\x20\x01(\x0e2..matrix_io.vision.v1.FacialRecognition.Glasses\
    R\x07glassesB\0\x1a\xee\x01\n\x10BasicFaceFeature\x122\n\x05mouth\x18\
    \x01\x20\x03(\x0b2\x1a.matrix_io.vision.v1.PointR\x05mouthB\0\x127\n\x08\
    left_eye\x18\x02\x20\x03(\x0b2\x1a.matrix_io.vision.v1.PointR\x07leftEye\
    B\0\x129\n\tright_eye\x18\x03\x20\x03(\x0b2\x1a.matrix_io.vision.v1.Poin\
    tR\x08rightEyeB\0\x120\n\x04nose\x18\x04\x20\x03(\x0b2\x1a.matrix_io.vis\
    ion.v1.PointR\x04noseB\0:\0\"]\n\x08AgeClass\x12\x19\n\x15AGE_CLASS_NOT_\
    DEFINED\x10\0\x12\x0c\n\x08CHILDREN\x10\x01\x12\x0f\n\x0bYOUNG_ADULT\x10\
    \x02\x12\t\n\x05ADULT\x10\x03\x12\n\n\x06SENIOR\x10\x04\x1a\0\"8\n\x06Ge\
    nder\x12\x16\n\x12GENDER_NOT_DEFINED\x10\0\x12\x08\n\x04MALE\x10\x01\x12\
    \n\n\x06FEMALE\x10\x02\x1a\0\"\x8e\x01\n\x07Emotion\x12\x17\n\x13EMOTION\
    _NOT_DEFINED\x10\0\x12\t\n\x05ANGRY\x10\x01\x12\x0b\n\x07DISGUST\x10\x02\
    \x12\x0c\n\x08CONFUSED\x10\x03\x12\t\n\x05HAPPY\x10\x04\x12\x07\n\x03SAD\
    \x10\x05\x12\r\n\tSURPRISED\x10\x06\x12\x08\n\x04CALM\x10\x07\x12\x08\n\
    \x04FEAR\x10\x08\x12\x0b\n\x07NEUTRAL\x10\t\x1a\0\"R\n\x07Glasses\x12\
    \x17\n\x13GLASSES_NOT_DEFINED\x10\0\x12\x0b\n\x07GLASSES\x10\x01\x12\x0e\
    \n\nNO_GLASSES\x10\x02\x12\x0f\n\x0bSUN_GLASSES\x10\x03\x1a\0:\0\"\xcf\
    \x01\n\nZoneConfig\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x125\
    \n\x07point_a\x18\x02\x20\x01(\x0b2\x1a.matrix_io.vision.v1.PointR\x06po\
    intAB\0\x125\n\x07point_b\x18\x03\x20\x01(\x0b2\x1a.matrix_io.vision.v1.\
    PointR\x06pointBB\0\x12\x18\n\x06height\x18\x04\x20\x01(\x05R\x06heightB\
    \0\x12!\n\x0breal_height\x18\x05\x20\x01(\x02R\nrealHeightB\0:\0\"\x9f\
    \x01\n\nAreaConfig\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x122\
    \n\x05point\x18\x02\x20\x03(\x0b2\x1a.matrix_io.vision.v1.PointR\x05poin\
    tB\0\x12E\n\x0fcount_direction\x18\x03\x20\x01(\x0b2\x1a.matrix_io.visio\
    n.v1.PointR\x0ecountDirectionB\0:\0\"\xd3\x01\n\x11AreaAndZoneConfig\x12\
    5\n\x04area\x18\x01\x20\x03(\x0b2\x1f.matrix_io.vision.v1.AreaConfigR\
    \x04areaB\0\x125\n\x04zone\x18\x02\x20\x03(\x0b2\x1f.matrix_io.vision.v1\
    .ZoneConfigR\x04zoneB\0\x12N\n\x12region_of_interest\x18\x03\x20\x03(\
    \x0b2\x1e.matrix_io.vision.v1.RectangleR\x10regionOfInterestB\0:\0\"\x80\
    \x01\n\rVehicleConfig\x12\x1f\n\ncamera_url\x18\x01\x20\x01(\tR\tcameraU\
    rlB\0\x12L\n\rarea_and_zone\x18\x02\x20\x01(\x0b2&.matrix_io.vision.v1.A\
    reaAndZoneConfigR\x0bareaAndZoneB\0:\0\"\xc0\x03\n\x0bVisionEvent\x121\n\
    \x03tag\x18\x01\x20\x01(\x0e2\x1d.matrix_io.vision.v1.EventTagR\x03tagB\
    \0\x12!\n\x0btracking_id\x18\x02\x20\x01(\x04R\ntrackingIdB\0\x12#\n\x0c\
    session_time\x18\x03\x20\x01(\x02R\x0bsessionTimeB\0\x12\x1f\n\ndwell_ti\
    me\x18\x04\x20\x01(\x02R\tdwellTimeB\0\x12\x19\n\x07area_id\x18\x05\x20\
    \x01(\x04R\x06areaIdB\0\x12\x19\n\x07zone_id\x18\x06\x20\x01(\x04R\x06zo\
    neIdB\0\x12K\n\x0ezone_direction\x18\x07\x20\x01(\x0e2\".matrix_io.visio\
    n.v1.ZoneDirectionR\rzoneDirectionB\0\x12\x16\n\x05speed\x18\x08\x20\x01\
    (\x02R\x05speedB\0\x12:\n\ttimestamp\x18\t\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\ttimestampB\0\x12\x1d\n\tarea_name\x18\n\x20\x01(\tR\x08\
    areaNameB\0\x12\x1d\n\tzone_name\x18\x0b\x20\x01(\tR\x08zoneNameB\0:\0\"\
    \xd7\x04\n\x14RectangularDetection\x12K\n\talgorithm\x18\x01\x20\x01(\
    \x0e2+.matrix_io.vision.v1.EnumDetectionAlgorithmR\talgorithmB\0\x12<\n\
    \x08location\x18\x02\x20\x01(\x0b2\x1e.matrix_io.vision.v1.RectangleR\
    \x08locationB\0\x129\n\x03tag\x18\x03\x20\x01(\x0e2%.matrix_io.vision.v1\
    .EnumDetectionTagR\x03tagB\0\x12\x20\n\nconfidence\x18\x04\x20\x01(\x02R\
    \nconfidenceB\0\x12W\n\x12facial_recognition\x18\x05\x20\x03(\x0b2&.matr\
    ix_io.vision.v1.FacialRecognitionR\x11facialRecognitionB\0\x12Z\n\x13veh\
    icle_recognition\x18\t\x20\x03(\x0b2'.matrix_io.vision.v1.VehicleRecogni\
    tionR\x12vehicleRecognitionB\0\x12\x16\n\x05speed\x18\n\x20\x01(\x02R\
    \x05speedB\0\x12\x16\n\x05image\x18\x06\x20\x01(\x0cR\x05imageB\0\x12!\n\
    \x0bimage_small\x18\x07\x20\x01(\x0cR\nimageSmallB\0\x12\x14\n\x04type\
    \x18\x0c\x20\x01(\tR\x04typeB\0\x12!\n\x0btracking_id\x18\x08\x20\x01(\
    \x04R\ntrackingIdB\0\x12\x14\n\x04uuid\x18\x0b\x20\x01(\tR\x04uuidB\0:\0\
    \"\\\n\tImageList\x12\x1f\n\nimage_data\x18\x01\x20\x03(\x0cR\timageData\
    B\0\x12,\n\x11frames_per_second\x18\x02\x20\x01(\x05R\x0fframesPerSecond\
    B\0:\0\"{\n\x05Video\x12\x1f\n\nvideo_data\x18\x01\x20\x01(\x0cR\tvideoD\
    ataB\0\x12;\n\x05codec\x18\x02\x20\x01(\x0e2#.matrix_io.vision.v1.EnumVi\
    deoCodecR\x05codecB\0\x12\x12\n\x03tag\x18\x03\x20\x03(\tR\x03tagB\0:\0\
    \"\x8e\x01\n\x05Image\x12\x16\n\x05image\x18\x01\x20\x01(\x0cR\x05imageB\
    \0\x12:\n\x06format\x18\x02\x20\x01(\x0e2\x20.matrix_io.vision.v1.ImageF\
    ormatR\x06formatB\0\x12/\n\x04size\x18\x03\x20\x01(\x0b2\x19.matrix_io.v\
    ision.v1.SizeR\x04sizeB\0:\0\"\xa2\x02\n\tFrameData\x12\x10\n\x02id\x18\
    \x01\x20\x01(\x04R\x02idB\0\x12;\n\nstart_time\x18\x02\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\tstartTimeB\0\x127\n\x08end_time\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTimeB\0\x12N\n\x08sectio\
    ns\x18\x04\x20\x03(\x0b20.matrix_io.vision.v1.FrameData.sections_MapEntr\
    yR\x08sectionsB\0\x1a;\n\x11sections_MapEntry\x12\x0e\n\x03key\x18\x01(\
    \tR\x03key\x12\x12\n\x05value\x18\x02(\x02R\x05value:\x028\x01:\0\"K\n\r\
    FrameDataList\x128\n\x06frames\x18\x01\x20\x03(\x0b2\x1e.matrix_io.visio\
    n.v1.FrameDataR\x06framesB\0:\0\"\x92\x04\n\x0cVisionResult\x12R\n\x0ere\
    ct_detection\x18\x01\x20\x03(\x0b2).matrix_io.vision.v1.RectangularDetec\
    tionR\rrectDetectionB\0\x12E\n\x0cvision_event\x18\x04\x20\x03(\x0b2\x20\
    .matrix_io.vision.v1.VisionEventR\x0bvisionEventB\0\x12?\n\x0cresult_ima\
    ge\x18\x05\x20\x01(\x0b2\x1a.matrix_io.vision.v1.ImageR\x0bresultImageB\
    \0\x12J\n\x12result_image_small\x18\x06\x20\x01(\x0b2\x1a.matrix_io.visi\
    on.v1.ImageR\x10resultImageSmallB\0\x12\x16\n\x05image\x18\x02\x20\x01(\
    \x0cR\x05imageB\0\x12!\n\x0bimage_small\x18\x03\x20\x01(\x0cR\nimageSmal\
    lB\0\x12\x14\n\x04uuid\x18\x07\x20\x01(\tR\x04uuidB\0\x12?\n\nframe_data\
    \x18\x08\x20\x01(\x0b2\x1e.matrix_io.vision.v1.FrameDataR\tframeDataB\0\
    \x12F\n\rmoment_of_day\x18\t\x20\x01(\x0e2\x20.matrix_io.vision.v1.Momen\
    tOfDayR\x0bmomentOfDayB\0:\0*\xde\x01\n\x18EnumFacialRecognitionTag\x12\
    \"\n\x1eFACIAL_RECOGNITION_NOT_DEFINED\x10\0\x12\x07\n\x03AGE\x10\x01\
    \x12\x0b\n\x07EMOTION\x10\x02\x12\n\n\x06GENDER\x10\x03\x12\x0b\n\x07FAC\
    E_ID\x10\x04\x12\r\n\tHEAD_POSE\x10\x05\x12\x11\n\rFACE_FEATURES\x10\x06\
    \x12\x13\n\x0fFACE_DESCRIPTOR\x10\x07\x12\x0b\n\x07IS_FACE\x10\x08\x12\
    \x0e\n\nHAVE_GLASS\x10\t\x12\t\n\x05BEARD\x10\n\x12\x0e\n\nTYPE_GLASS\
    \x10\x0b\x1a\0*R\n\x19EnumVehicleRecognitionTag\x12#\n\x1fVEHICLE_RECOGN\
    ITION_NOT_DEFINED\x10\0\x12\x0e\n\nFAMILY_CAR\x10\x01\x1a\0*L\n\rZoneDir\
    ection\x12\x1e\n\x1aZONE_DIRECTION_NOT_DEFINED\x10\0\x12\x0b\n\x07FORWAR\
    D\x10\x01\x12\x0c\n\x08BACKWARD\x10\x02\x1a\0*\x87\x01\n\x08EventTag\x12\
    \x15\n\x11EVENT_NOT_DEFINED\x10\0\x12\x12\n\x0eTRACKING_START\x10\x01\
    \x12\x10\n\x0cTRACKING_END\x10\x02\x12\x0e\n\nAREA_ENTER\x10\x03\x12\r\n\
    \tAREA_EXIT\x10\x04\x12\x0e\n\nZONE_ENTER\x10\x05\x12\r\n\tZONE_EXIT\x10\
    \x06\x1a\0*\x83\x01\n\x10EnumDetectionTag\x12\x19\n\x15DETECTION_NOT_DEF\
    INED\x10\0\x12\x08\n\x04FACE\x10\x01\x12\x0e\n\nHAND_THUMB\x10\x02\x12\r\
    \n\tHAND_PALM\x10\x03\x12\x0e\n\nHAND_PINCH\x10\x04\x12\r\n\tHAND_FIST\
    \x10\x05\x12\n\n\x06PERSON\x10\x06\x1a\0*c\n\x16EnumDetectionAlgorithm\
    \x12#\n\x1fDETECTION_ALGORITHM_NOT_DEFINED\x10\0\x12\x0b\n\x07DEFAULT\
    \x10\x01\x12\x15\n\x11FIRST_ALTERNATIVE\x10\x02\x1a\0*z\n\x0eEnumVideoCo\
    dec\x12\x1b\n\x17VIDEO_CODEC_NOT_DEFINED\x10\0\x12\x19\n\x15UNDEFINED_VI\
    DEO_CODEC\x10\x01\x12\x08\n\x04H264\x10\x02\x12\x08\n\x04MP4V\x10\x03\
    \x12\x08\n\x04RV24\x10\x04\x12\x07\n\x03VP8\x10\x05\x12\x07\n\x03VP9\x10\
    \x06\x1a\0*q\n\x0bImageFormat\x12\x1c\n\x18IMAGE_FORMAT_NOT_DEFINED\x10\
    \0\x12\x0f\n\x0bUNSPECIFIED\x10\x01\x12\x10\n\x0cFORMAT_8URGB\x10\x02\
    \x12\x10\n\x0cFORMAT_8UBGR\x10\x03\x12\r\n\tFORMAT_8U\x10\x04\x1a\0*B\n\
    \x0bMomentOfDay\x12\x1d\n\x19MOMENT_OF_DAY_NOT_DEFINED\x10\0\x12\x07\n\
    \x03DAY\x10\x01\x12\t\n\x05NIGHT\x10\x02\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
